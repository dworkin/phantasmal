<h2><a name="SEC4.2" href="index.html#SEC4.2" id="SEC4.2">LPC
revisited</a></h2>

<p>Let's go through more of the LPC constructs that we didn't
finish in the LPC Basics section. Now that you know the basics and
can use them for simple scripts, it's time to find out more of what
LPC can do.</p>

<h3><a name="SEC4.2.2" href="index.html#SEC4.2.2" id=
"SEC4.2.2">Inheriting object classes</a></h3>

<p>Assume that you want to code a door. Doing that means that you
have to create functionality that allows the opening and closing of
a passage between two rooms. Perhaps you want to be able to lock
and unlock the door, and perhaps you want the door to be
transparent. All of this must be taken care of in your code.
Furthermore, you have to copy the same code and make small
variations in description and use <i>every time</i> you want to
make a new door.</p>

<p>After a while you'll get rather tired of this, particularly
because you'll find that other wizards have created doors of their
own that work almost - but not quite - the same way your does,
rendering some of your nifty objects and features useless anywhere
but in your domain.</p>

<p>The object oriented way of thinking is that instead of doing
things over and over, you create a basic door object that can do
all the things you want any door to be able to do. Then you just
inherit this generic door into a specialized door object where you
configure exactly what <i>it</i> should be able to do from the list
of available options in the <b>parent</b> door.</p>

<p>It is even possible to inherit several different objects in
order to combine the functionality of several object types into
one. Be aware that if a class's parent objects define functions
with the same names, they will clash. It may not be easy to fix
this problem, so avoid inheriting from more than one parent until
you're reasonably sure what you're doing.</p>

<p>The syntax for inheriting objects is very simple. In the top of
the file you write this:</p>
<pre>
[private] inherit [prefix] "&lt;file path&gt;";
e.g.
        inherit "/std/door";
        inherit "/usr/common/object";
        private inherit foo "/usr/bob/secret_parent";
    
</pre>

<p>Note that this is <i>not</i> a preprocessor command, it is a
statement, so it does <i>not</i> have a <code>#</code> in front of
it. It also ends with a <code>;</code>. You may specify that it's a
<tt>.c</tt> file if you wish, but doing so isn't required.</p>

<p>Inheritance statements <i>must</i> come before any variable or
function definitions, including in #include files. This is one
reason you can't use the standard include file (mentioned in a
later chapter) to add a variable to every LPC program -- if you
did, that variable would be declared before any inheritance, so no
LPC program could inherit anything!</p>

<p>The <b>child</b> object (the one that declares the inheritance,
as above) will inherit all inheritable functions and variables.
This means that simply calling a function with the name declared in
the parent will call that function as the parent defines it. Or, if
the child defines it, it will be called with the child's
definition. That is the power of inheritance -- the same name can
refer to any of a family of functions, tailored to different
classes.</p>

<p>Variables are also inherited, and can be referred to by name.
The variable's name, by itself, points to the parent's instance of
that variable, so it works just like functions.</p>

<p>If a child object has a function with the same name as a
function in the parent, the child's function will <b>mask</b> the
parent's. When the function is called by an external call to the
child, the child function will be executed. To call the parent
function from the child, call the function name with the scope
operator, <code>::</code>, before it.</p>
<pre>
void my_func()
{
    /* 
     * This function exists in the parent, and I need to
     * call it from here.
     */
    ::my_func();        /* Call my_func() in the parent. */
}
    
</pre>

<p>If a parent is inherited with a prefix, for example, <tt>inherit
foo "/usr/bob/fooclass"</tt>, the method above won't work. Instead
of calling with a scope operator before it, it must be called with
the prefix, the scope operator and then the function name. So
<tt>::my_func();</tt> above might become
<tt>foo::myfunc();</tt>.</p>

<p>It is not possible to call a masked function in the parent by an
external call -- only from within the object itself. If an object
inherits an object that has inherited another object, e.g. C
inherits B that inherits A, then masked functions in A are
available in B. If B masks that function then C will get B's
version when it calls the function with the scope operator. If B
doesn't mask the function then C would get A's version instead.</p>

<p>If a parent is inherited with the <b>private</b> keyword, only
the class inheriting it will be able to see its functions. External
function calls won't find the <b>private</b> parent's functions,
and child classes won't be able to call the functions inherited
from that parent. To export the functions in a <b>private</b>
parent class, have the child class declare functions with the same
names that pass the arguments through to the parent.</p>

<h3><a name="SEC4.2.3" href="index.html#SEC4.2.3" id=
"SEC4.2.3">Type identification</a></h3>

<p>Due to the fact that all variables are initialized to 0 or nil,
and that many functions return 0 or nil when failing, it's
desirable to be able to determine what value you actually have
received. If you use the <code>mixed</code> type it's even more
essential to be able to test what the <b>mixed</b> variable
contains at any specific time. For this purpose there's a special
function called <code>typeof()</code>. It uses constants listed in
the header file &lt;type.h&gt;.</p>

<p>Calling typeof() on a value returns one of the constants from
<tt>type.h</tt>, though you may get a type different from the one
the variable has. For instance, an uninitialized string, array or
mapping will return T_NIL rather than T_STRING, T_ARRAY or
T_MAPPING. This is true even if typeof() is called on a variable of
type <b>string</b> rather than type <b>mixed</b>.</p>

<p>One excellent use for typeof() is to write a function which
allows multiple possible types for a single parameter and checks
the type of that parameter inside. For instance:</p>
<pre>
#include &lt;type.h&gt;

string mixed_print_to_string(mixed arg)
{
    switch(typeof(arg))
    {
        case T_NIL:
            return "(nil)";
        case T_STRING:
            return "\"" + arg + "\"";
        case T_INT:
        case T_FLOAT:
            return "" + arg;
        case T_OBJECT:
            return "&lt;" + object_name(arg) + "&gt;";
        case T_ARRAY:
            {
                int    ctr;
                string tmp;

                tmp = "({ ";
                for(ctr = 0; ctr &lt; sizeof(arg) - 1; ctr++)
                {
                    tmp += mixed_print_to_string(arg[ctr]);
                    tmp += ", ";
                }
                /* We go one less iteration and then add the final
                   element by hand to avoid a stray comma at the
                   end. */
                tmp += mixed_print_to_string(arg[sizeof(arg) - 1]);
                return tmp;
            }
        default:
            error("We don't print those yet!");
    }
}
    
</pre>

<h3><a name="SEC4.2.4" href="index.html#SEC4.2.4" id=
"SEC4.2.4">Type qualifiers</a></h3>

<p>The types you assign to variables and functions can have
qualifiers changing the way they work. It's very important to keep
these qualifiers in mind and use the proper ones at the proper
times. Most work differently when applied to variables rather than
functions, so try to avoid confusion by remembering that, for
instance, a static variable and a static function have little, if
anything, to do with each other.</p>

<h4><a name="SEC4.2.4.1" href="index.html#SEC4.2.4.1" id=
"SEC4.2.4.1">The static variable qualifier</a></h4>

<p>Static variables must be global variables. Global variables are
variables defined outside of any function in the file. These
variables are visible and usable in all functions defined later in
the file than they are, so their <b>scope</b> is object-wide rather
than limited to one function.</p>

<p>It is possible to save the global variables of an object with a
function called <code>save_object</code> and restore them with
<code>restore_object</code>. If a global variable is declared as
<code>static</code>, it is <i>not</i> saved or restored along with
the others. DGD doesn't particularly recommend using
<code>save_object</code> anyway -- it's better to use statedumps or
some other form of structured storage in most cases.</p>
<pre>
static string   TempName;  /* An example of a non-saved global variable. */
    
</pre>

<h4><a name="SEC4.2.4.2" href="index.html#SEC4.2.4.2" id=
"SEC4.2.4.2">The static function qualifier</a></h4>

<p>A function that is declared <code>static</code> can not be
called using external calls (call_other), only internal. This makes
the function invisible and inaccessable to other objects. Child
classes of the object may call the object's static functions, so be
sure to take that into account. Functions that check the caller
with <code>previous_program()</code> may be better for security
purposes. You can also combine the two approaches.</p>

<p>Since you can't call a static function with call_other() from
another object, you also can't call it with object-&gt;func()
syntax, since that's equivalent to call_other(). If the static
function is later masked (see the 'nomask' function modifier for
details on masking), the call won't be redirected as usual.</p>

<p>Static functions defined by the AUTO object (see chapter 5) are
special. They are treated just like built-in kernel functions --
they can't be called with call_other(), for instance.</p>

<h4><a name="SEC4.2.4.3" href="index.html#SEC4.2.4.3" id=
"SEC4.2.4.3">The private function and variable qualifier</a></h4>

<p>A variable or function that has been declared
<code>private</code> will not be usable by other objects, including
child objects. Private functions and variables can only be accessed
by the object that defines them. Private variables, like
<code>static</code> variables, are not saved by
<code>save_object()</code>.</p>

<h4><a name="SEC4.2.4.4" href="index.html#SEC4.2.4.4" id=
"SEC4.2.4.4">The nomask function qualifier</a></h4>

<p>Functions that are declared as <code>nomask</code> can not be
masked by inheritance. That is to say, a child object may not
declare another function with the same name. Normally a function
with the same name in a child object would simply replace the
original function silently (called <i>masking</i> it). A function
marked <code>nomask</code> may not be replaced in this way.
Attempting to do so gives an error message.</p>

<p>Since an internal call will still use the child class's method
definition by default, <code>nomask</code> functions provide a way
to be sure what method is being called. Functions that are declared
as both <code>static</code> and <code>nomask</code> are a powerful
way to make sure a function can be called only by child classes,
but the definition of the function will always be known for any
child class. A <code>private</code> function may not also be
declared <code>nomask</code>.</p>

<p>Variables may not be marked <code>nomask</code> -- they have the
same functionality automatically, so there is no use for a
<code>nomask</code> variable modifier.</p>

<h4><a name="SEC4.2.4.5" href="index.html#SEC4.2.4.5" id=
"SEC4.2.4.5">The atomic function qualifier</a></h4>

<p>Atomic functions are very powerful, and are specific to DGD Only
functions may be declared atomic, not variables. The
<code>atomic</code> modifier is used just like the
<code>static</code> or <code>nomask</code> modifier, before a
function's name.</p>

<p>If a function is declared <code>atomic</code>, it may not read,
write, move or rename files in any way. It may not read or write
network data on network connections. Any attempt to do so will
cause an error. Atomic functions also use a different error handler
than non-atomic functions. They use up twice as many ticks per
operation as non-atomic functions (see <code>rlimits</code> for an
explanation of ticks).</p>

<p>So what's different about them? It's the fact that they will
either execute completely and without error, or nothing will
happen. You can call other functions or write to global variables
and data structures in an atomic function, even if those variables
or data structures are in a different object than the atomic
function. If an error occurs and the function terminates, those
writes to variables and data structures will be fully undone, as
will the calls to other objects. It is as though the atomic
function has never been called at all, except for the fact that it
causes an error to be handled.</p>

<p>Calls to atomic functions may be nested. That is to say, atomic
functions may call other atomic functions, catching errors if
necessary. They may also, of course, call non-atomic functions.
Changes will only be undone when an error forces execution to leave
the atomic function; an error caught within an atomic function will
not be undone. If an error is caught in code that called the atomic
function, changes will be undone before the error is caught.</p>

<p>Atomic functions are one of the most powerful features of DGD.
They are found in no other commonly-used language, although many
databases have a very similar feature. Several languagues like
Prolog have backtracking, which can be used for similar purposes,
but that's often much less convenient than atomic functions for
standard MUD operations.</p>

<h3><a name="SEC4.2.5" href="index.html#SEC4.2.5" id=
"SEC4.2.5">switch/case part 2</a></h3>

<p><a name="IDX73" id="IDX73"></a> <a name="IDX74" id="IDX74"></a>
The LPC switch statement is very intelligent, it can also use
ranges in integers:</p>
<pre>
void wheel_of_fortune()
{
    int i;

    i = random(10);     /* Get a random number from 0 to 9 */

    switch (i)
    {
    case 0..4:
        write("Try again, sucker!\n");
        break;

    case 5..6:
        write("Congrats, third prize!\n");
        break;

    case 7..8:
        write("Yes! Second prize!\n");
        break;

    case 9:
        write("WOOOOPS! You did it!\n");
        break;

    default:
        write("Someone has tinkered with the wheel... Call 911!\n");
        break;
    }
}
    
</pre>

<h3><a name="SEC4.2.6" href="index.html#SEC4.2.6" id=
"SEC4.2.6">catch/error: Error handling at runtime</a></h3>

<p><a name="IDX75" id="IDX75"></a> It happens now and then that you
need to make function calls you know <i>might</i> result in a
runtime error. For example you might try to clone an object
(described later) or read a file. If the files aren't there or your
privileges are wrong you will get a runtime error and execution
will stop. In these circumstances it is desirable to intercept the
error and either alert a user or try alternate solutions to the
problem. The special LPC function operator <code>catch()</code>
will do this for you. If an error occurs during evaluation of the
given function, the error is returned.</p>
<pre>
int catch(function)
e.g.
    if (catch(write_file("/usr/bob/logfile", "It works!")))
    {
        DRIVER-&gt;message("You don't have permission to write!\n");
        return;
    }
    
</pre>

<p><a name="IDX76" id="IDX76"></a> It's also possible to cause
errors. This is particularly useful when you want to notify the
user of an unplanned event that occured during execution. For
instance, you often want to do this in the 'default' case of a
switch statement. In any case, <code>error()</code> will generate a
runtime error with the message you specify. A <code>catch()</code>
statement issued prior to calling the function that uses
<code>throw()</code> will intercept the error as usual.</p>
<pre>
error(string message)
e.g.
    if (test &lt; 5)
        error("The variable 'test' is less than 5\n");
    
</pre>

<h3><a name="SEC4.2.7" href="index.html#SEC4.2.7" id=
"SEC4.2.7">Array and Mapping references</a></h3>

<p><a name="IDX77" id="IDX77"></a> <a name="IDX78" id="IDX78"></a>
In computer science terms, arrays and mappings are copied <b>by
reference</b> and simpler types are copied <b>by value</b> This
means that arrays and mappings, unlike other variables, aren't
copied every time they are moved around. Instead, what is moved is
a reference to the original array or mapping. What does this mean
then?</p>

<p>Here's an example:</p>
<pre>
object *arr, *copy_arr;

arr = ({ 1, 2, 3, 4 });    /* An array */

copy_arr = arr;              /* Assume (wrongly) that a copy_arr becomes
                                a copy of arr. */

/* Change the first value (1) into 5. */
copy_arr[0] = 5;
    
</pre>

<p>It might be logical to assume that the first value of
<code>copy_arr</code> is 5 while the first value or
<code>arr</code> is 1. That's not the case, because what got copied
into <code>copy_arr</code> was not the array itself, but a
reference to the same array as <code>arr</code>. This means that
assigning an element changed that element in the original array to
which both variables refer. <code>copy_arr</code> and
<code>arr</code> will both seem to have changed, while in fact it
was only the original array that changed.</p>

<p>Exactly the same thing will happen for mappings since they are
also copied by reference.</p>

<p>How do you copy an array or mapping by value? Usually you want
to work on a copy and not the original array or mapping.</p>
<pre>
              _ This is just an empty array
             /
copy_arr = ({ }) + arr;
                    \_ This is the one we want to make unique
    
</pre>

<p>In this example <code>copy_arr</code> becomes the sum of the
empty array and the <code>arr</code> array created as an entirely
new array. This leaves the original unchanged, just as we wanted.
You can do exactly the same thing with mappings. It doesn't matter
if you add the empty array or mapping first or last, just as long
as you do it.</p>

<p>You can also copy arrays using array-slice notation. This is
probably the most common in existing DGD code.</p>
<pre>
copy_arr = arr[..];
    
</pre>

<p>At the end of a thread of execution, any array that is in a new
object will be copied into that object. That means you can't just
store references to a single array in a lot of your objects and use
those references to share data. At the end of their first thead of
execution, each referenced mapping and array will be copied into
all the objects that reference them, and they'll stop being the
same as the original. To share data like that, you should put the
array in a single object and make a function that returns the
array. Then any object that wants to modify it can call the
function, modify the array and then stop referencing it before the
thread of execution is over. You could also have separate "get" and
"set" functions, which would be slower but easier to control.</p>

<p>For details on what threads of execution are and when they end,
see section 5.3.1 in chapter 5.</p>
<hr>
<a href="http://sourceforge.net"><img src=
"http://sourceforge.net/sflogo.php?group_id=48659&amp;type=6"
width="210" height="62" border="0" alt="SourceForge.net Logo"></a>

<address>
  <a href="mailto:noah_gibbs@yaNOSPAMhoo.com">Noah Gibbs</a>
</address><!-- Created: Mon Jun 11 21:50:30 PDT 2001 -->
<!-- hhmts start -->
Last modified: Tue Jul 1 15:01:01 PDT 2003 <!-- hhmts end -->
