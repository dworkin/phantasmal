<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DGD and LPC: Object Cleanup</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../../phantasmal.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="95%" border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td colspan="2"> <table width="100%" border="0" cellspacing="1"
        cellpadding="0" class="main">
        <tr>
          <td class="banner">The DGD Driver</td>
        </tr>
      </table></td>
  </tr>
  <tr>
    <td valign="top">
      <table width="25%"  border="0" cellspacing="1"
             cellpadding="0"  class="main">
        <tr>
          <td class="content" style="font-size: 120%">

          <ul style="margin: 0; padding-left: 10%">
            <li> <a href="index.html">DGD &amp; LPC Page</a> </li>
	    <li> <a href="../LPC">LPC Textbook</a> </li>
	    <li> <a href="../Book">New LPC Introduction</a> </li>
          </ul>

        </td>
        </tr>
        <tr>
          <td class="content" align="center">
            <a href="http://validator.w3.org/check/referer">
            <img src="../../images/valid-xhtml10.gif" alt="Valid XHTML 1.0!"
             style="border:0;width:88px;height:31px" /></a><br />
            <img src="../../images/pixel.gif"
             style="border:0;width:88px;height:1px" alt="" /><br />
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
            <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!" style="border:0;width:88px;height:31px" />
            </a><br /><br /><br />
            <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
             style="border: 0; width: 125; height: 37;"
	     alt="SourceForge.net Logo" /></a>
          </td>
        </tr>
      </table></td>
    <td> <table width="100%"  border="0" cellspacing="1" cellpadding="0" 
          class="main">
        <tr>
          <td class="heading">&nbsp;&nbsp;&middot;&nbsp;
	    <a href="http://phantasmal.sf.net/DGD">DGD Page</a> &gt;
            <a href="">Object Cleanup</a>
          </td>
        </tr>
        <tr>
          <td class="content">
  

  <h2> Cleaning Up Stray Objects </h2>

  <p>
    If you're running a persistent MUD, chances are good that you'll
    occasionally get a stray object sitting around, something that's
    no longer useful, and may never have been useful.  You'd like to
    get rid of objects like that because otherwise they can stick
    around for (quite literally) years.  How can you do it?
  </p>

  <p>
    The Kernel Library has some tools that you may want to use, or may
    just want to duplicate for your own MUD.  For instance, it has a
    daemon called ObjRegD, which keeps a list of every clone and who
    owns it.  That allows authorized users to look through the lists
    and get rid of old clones that are no longer in use, if they can
    figure out whether it's being used.
  </p>

  <p>
    In addition to the ObjRegD, it's possible in extreme or desperate
    cases to parse through a statedump.  You could also verify the
    contents of your object management code by reading the statedump,
    if necessary...  Any disagreement between them means a bug in your
    code.  The statedump has a fixed format, and the code that writes
    and parses it (the DGD server) is open to you, so you can verify
    that format easily enough.  Richard Braakman did this with the
    early DGD 1.1.X dumpfile format.
  </p>

  <h3> Quotas </h3>

  <p>
    It's often a good idea to enforce quotas on how many LPC objects
    and how much memory a given administrator can use.  By doing that,
    and allowing the administrator to list what objects he is
    currently being 'billed' for (using the ObjRegD above,
    presumably), you can have administrators do much of your cleanup
    for you.  Periodic warnings for admins that are near their quota
    is a good way to make them clean up <i>before</i> they hit the
    actual limit and things start to go wrong.
  </p>

  <h3> Heuristics </h3>

  <p>
    What might you want to check for to determine if an object is
    unused?  Well, you can see who owns it &mdash; it's possible that
    you'll want to get rid of every object created by a now-inactive
    administrator when he leaves.  However, you might want to first
    check the objects and make sure they aren't in active zones.  That
    administrator might have done some building you weren't aware of.
    Those objects can first be transferred to the ownership of a
    different administrator, and then all the old admin's objects can
    be purged.
  </p>

  <p>
    You could keep track of how recently an object has been
    referenced.  If you update a time counter every time an object is
    picked up or used, you can determine what objects are more likely
    to be missed if they disappear.  Then you can look through the
    least-used objects by hand and eliminate any that seem
    superfluous.  However, this method has some pitfalls: make sure
    that objects like statues in highly-trafficked areas (which are
    seen often but almost never used) will not be marked as unused.
    If an object is seen often, you'll want to keep it.  Similarly, an
    active player may want to keep a 'buried treasure' somewhere out
    of the way where other players can't find it.  If you keep track
    of object owners, it may be easier to never get rid of an object
    owned by a currently-active player.
  </p>

  <p>
    To avoid problems like the above, you might simply never get rid
    of any 'physical' object in a player-accessible zone of the MUD.
    That will make it easier to track down only unused 'virtual'
    objects, or objects with no 'physical' location.
  </p>

  <p>
    It's possible to use the status() kfun to get the most recent
    stored size of an object.  If you're trying to reduce the in-RAM
    footprint of your MUD rather than just getting rid of the largest
    number of (possibly small) objects, you might want to get a
    listing of objects ranked by size, which will let you optimize or
    remove the largest objects.
  </p>

<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Mon Oct 20 14:42:00 2003
Subject: [DGD] Some basics

Stephen Schmidt wrote:

>[...]
> This raises a general question. When there are circular
> references in a data structure (A refers to B which refers
> to C which refers to A) then nothing can be destructed -
> A can't be destructed because C refers to it, but C can't
> be destructed because B refers to it and B can't be destructed
> because A refers to it. But circular inheritance isn't (had
> better not be!) possible.
>
> Question 1: Can this kind of problem arise in ObjectD?
>
> Question 2: I have a dim memory that LPMud, and maybe MudOS
> also, suffered from something called a "lifetime lvalue bug"
> which was never explained to me, but which was some kind of
> circular-reference garbage-collection problem. Does DGD have
> this problem as well? If so, what the heck is it? Or is my
> memory just wrong in this case?

Answering both questions together: DGD takes care of this.  Don't worry
about it.  The latest version in the experimental line does so
automatically, and the 1.2pX line does it when a swapout() call is made.

Regards,
Dworkin
</pre>

<hr />

<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Thu Aug 19 19:57:01 2004
Subject: [DGD] Object house-keeping and persistance

Birgit Schulte wrote:

> I am wondering about ways to make sure the number of unused / discarded
> objects in
> a persistant mud doesn't go through the roof.

It may not be what you want, but this is one of the things I designed
the resource management subsystem for, and I'll explain my reasons.

Object cleanup as it exists in the original LPmud is very limited.  It
only works for rooms, and only under specific circumstances.  Rooms
are precisely the objects that in DGD you do not want to destruct, and
that you do not have to destruct.  So the whole idea of object cleanup
as it exists in LPmud doesn't apply to DGD.

How can the mudlib of a persistent mud determine that an object is
unused, and can be destructed?  The answer is that in the general case,
it can't, because it is impossible to second-guess the LPC programmer.
What you could do is let objects voluntarily register for a "cleanup
list", destruct them when certain conditions specific to that cleanup
list have been met, and recreate them if you should need them again.
Objects that don't have to be recreated at all will then eventually
be cleaned up, and gone forever.  But you will also be doing a lot
of destructing and recreating, because objects that <are> still in
use will also be in that list.  It would be even better if those
objects were never destructed at all.  And of course it is possible
that some rogue objects never register for any cleanup list in the
first place.

Therefore I decided to leave the selection of objects to destruct
to the programmer.  To inspire the programmer to actually do that,
I made an object quota.  Let's say that everyone starts out with
space for 100 objects.  How you use that is entirely your business.
>From the mud admin's point of view, all of these objects will be
"in use".  But the programmer who runs out of free objects will be
motivated to recycle some old ones (provided of course that the
tools to do that are available), or else will have to answer the
question, "why do you need more than 100 objects?"

Regards,
Dworkin
</pre>

<hr />

<pre>
From: dgd at list.imaginary.com (Michael McKiel)
Date: Fri Aug 20 01:00:02 2004
Subject: [DGD] Object house-keeping and persistance

The way we intend it, will be wizard's whose areas haven't gone thru QC yet
will not have a "in game" flag, or will have a "testing" flag. Any such
object with a "testing" flag if it ever enters an environment that is not
flagged testing then it destructs itself. As well as any item that is flagged
as a test item when a *player* enters a non-testing room -- perhaps such test
items when just carried by wizards wouldn't destruct. 

And you may wonder how a player might obtain these "test" objects, well a
wizard might give it out illegally, or players might be requested to play
test an area before it goes live.
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
            <address>
            <span><a href="mailto:angelbob-remove-spamfree@spamfree.users.sf.net">Noah Gibbs</a></span>
            </address></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
