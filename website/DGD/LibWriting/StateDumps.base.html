  <titledef text="State Dumps" />

  <h2> DGD's State Dumps </h2>

  <p>
    Statedumps provide a way to dump DGD's memory space to disk, much
    as the swapfile does, and restore it at a later time.  All program
    state is maintained.  Pointers continue to work, call_out()
    statements are still scheduled, objects that are previously
    un-upgraded remain that way until recompiled in the standard DGD
    way.  The only difference after a statedump is that network
    connections are broken (of course), and that you can alter the
    code of the DGD server, perhaps by upgrading versions or changing
    the configuration file.  Statedumps are almost invariably forward
    compatible to new stable DGD versions, and there are several other
    upgrades you can make, such as increasing the maximum number of
    objects, which will be transparently caught and permitted with an
    old statedump file.
  </p>

  <p>
    A statedump makes the old save_object() and restore_object()
    functions redundant for saving your MUD's state as a whole, though
    they can occasionally be useful for saving an individual object or
    three.  Like with save_object(), the resulting statedump file can
    contain security-sensitive information, so it should ideally be
    stored where only highly-privileged code can read it.
  </p>

  <p>
    Statedumps are a highly-necessary part of <a
    href="Persistence.html">persistence</a> in a MUD Library.  Skotos
    Tech's Castle Marrach used them since early development, keeping a
    'virtual uptime' from 1999 into 2004 and beyond.
  </p>

  <p>
    Statedumps, like shutdowns and object recompilation, take place
    immediately after the thread that requested them has ended.  The
    thread that would otherwise immediately follow will occur, but not
    until after the server has been restarted with the just-saved
    statedump.
  </p>

  <p>
    Statedumps are able to handle DGD's normal policy of having far
    more LPC data than available memory.  Normally, a statedump will
    be made incrementally and you can simply tell DGD when to put the
    finishing touches on it, declare it done, and begin writing out
    (what will be) the next incremental statedump.  By telling DGD
    approximately how often you'll be dumping state, you make it much
    easier for the server to write the statedump in a timely way when
    you request it &mdash; nearly all the work has been done in
    advance.
  </p>

  <p>
    Statedumps are, generally speaking, the fastest way to do backups
    in DGD.  You should use them regularly for that purpose, in case
    your game crashes.  Castle Marrach's statedump, circa 2004, was
    nearly 2GB in size.  Its statedump usually took only a few
    seconds, only occasionally going into the 10-20 seconds range.
    That's not a lot of time required, so backing up (say) every hour
    won't cause your MUD a lot of lag.
  </p>

  <h3> Restoring </h3>

  <p>
    When you restore from a statedump, all your previous objects are
    exactly where they were.  However, your network connections, if
    any, have been closed.  You should destruct them if it's necessary
    to do so explicitly.  See the Kernel Library's code for details, or
    use the Kernel Library to make even that part of restoration fully
    transparent.
  </p>

  <h3> Cleanup </h3>

  <p>
    A certain amount of object fragmentation is removed and other
    cleanup tasks done when objects are swapped out.  For that reason,
    it's often good to make sure that DGD is permitted to do at least
    some <a href="Swapping.html">swapping</a>.
  </p>

<pre>
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Wed Dec 26 07:42:01 2001
Subject: [DGD] Dynamic inheritance

Wes Connell wrote:

>[..]
> >  > I think you might be better off just burning the extra memory and saving 
> >  > yourself some unnecessary complexity.
>
> Perhaps my database theory is off here... but why couldn't the DGD driver do
> incremental updates? (Feel free to rant on me, I desire a good whoopin' on
> database theory. *chuckle*)

Right now, DGD basically turns the swapfile into a statedump in a single
stroke, and then slowly rebuilds the swapfile over time; in the meantime,
the dumpfile can already be copied on tape or whatever.  To make an
incremental update, you have to save a delta with the previously stored
state.  On a busy mud, I would expect this to take more time.

Of course, you could create the incremental dump slowly, just like DGD
already recreates the swapfile slowly.  But at this point you need some
way to signal when the incremental dump is ready, and there are other
complications, so that it would be better to just use existing database
software to store the mud's state, which has already solved all of these
problems.

I intend to make the latter possible by publishing an interface for
DGD's state handling, like the extension interface, as soon as the
code is settled enough after the on-going MP rewrite.

Regards,
Dworkin
</pre>

<hr />

<pre>
From: DGD Mailing List (Noah Gibbs)
Date: Thu Jan  8 14:43:00 2004
Subject: [DGD] Persistance

--- Robert Forshaw wrote:
> When you eventually do reboot, how will it
> reconnect the rooms? Doing it by 
> file name makes this easy, but by object
> reference, well, for a start every 
> room object will have to be loaded, and then
> how is it going to figure out 
> what rooms connect to where, if not by file
> name?

  Here's a clarification that may help.  Under Unix,
there's something called a core dump.  Conceptually,
it's kind of like a DGD statedump.  The idea is that
the process's memory is all written out, along with
*all* its state, into a big file.  That file contains
the entire application in exactly the state it was in
when it core dumped.

  Usually, coredumps are used for debugging.  But
certain very clever applications use them for other
purposes.  For instance, emacs and some Perl
applications use them for compiling.  They go through
a very long startup sequence (several hours for
emacs), and then the dump core *without* crashing.

  When you run emacs, or run a precompiled Perl
binary, what happens is that core dump gets loaded
right back into memory, in the exact state where it
dumped core.  From the newly-loaded app's point of
view, it just dumped core and now it's time to run. 
Every time you run the app, you're restoring from its
just-after-build application state, without having to
wait for hours of startup while it compiles many
megabytes of code.

  DGD statedumps work a lot like coredumps.  All your
current running code is dumped.  All your objects are
dumped.  All your data is dumped.  All the stuff in
the swapfile is dumped.

  And when you put it back, it's as though it had
never been gone.  If you have a chunk of code which
contains a statedump, you won't know on the line after
that statedump if you just breezed through it, or if
you've just been restored, minutes or weeks or decades
later, from that statedump.  Maybe all your net
connections just went down (they do that when you
restore years later, alas).  Maybe your system clock
just advanced by a couple of weeks.  It's hard to
tell.  Because your function will continue just fine
ten years later, and may *not even realize* that you
just dumped state and restarted.

  I'm exaggerating slightly.  I think the statedump
happens just after the thread exits.  But when the
call_out that you scheduled ten years ago happens, it
won't know that it was scheduled ten years ago.  It'll
just know that it's time to run again :-)
</pre>

<hr />

<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Tue Apr  6 06:46:01 2004
Subject: [DGD] DGD-Fishing

Ragnar Lonn wrote:

> > > While I'm at it I might aswell ask about state dumps also. Are they
> > > as optimised as can be?  Is it or would it be possible to somehow create
> > > state dumps without the noticeable pause of the game?
> >
> > How long is noticable?
> >
>
> Hmm, I'd say around 0.5 seconds and the state dump wouldn't be easily
> noticeable by the players in an MMORPG-style game.
>
> But in my own case streaming state changes to another DGD instance might
> mean I don't have to do state dumps, or that I can do them on the backup
> DGD instance and not bother players with the lag. I was just curious as
> to whether it was possible to speed them up in case the streaming thing
> wouldn't work as hoped.

Half a second or less would be hard to guarantee for a big mud.  DGD is
not designed for unnoticable statedumps, but for statedumps that are
fast enough that the delay they cause does not seem significantly
different from delay due to packet loss.

Regards,
Dworkin
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
