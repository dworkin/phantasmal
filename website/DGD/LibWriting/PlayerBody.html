<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DGD and LPC: Player vs Body</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../../phantasmal.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="95%" border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td colspan="2"> <table width="100%" border="0" cellspacing="1"
        cellpadding="0" class="main">
        <tr>
          <td class="banner">The DGD Driver</td>
        </tr>
      </table></td>
  </tr>
  <tr>
    <td valign="top">
      <table width="25%"  border="0" cellspacing="1"
             cellpadding="0"  class="main">
        <tr>
          <td class="content" style="font-size: 120%">

          <ul style="margin: 0; padding-left: 10%">
            <li> <a href="../index.html">DGD &amp; LPC Page</a> </li>
	    <li> <a href="../LPC">LPC Textbook</a> </li>
	    <li> <a href="../Book/html">New LPC Introduction</a> </li>
          </ul>

        </td>
        </tr>
        <tr>
          <td class="content" align="center">
            <a href="http://validator.w3.org/check/referer">
            <img src="../../images/valid-xhtml10.gif" alt="Valid XHTML 1.0!"
             style="border:0;width:88px;height:31px" /></a><br />
            <img src="../../images/pixel.gif"
             style="border:0;width:88px;height:1px" alt="" /><br />
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
            <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!" style="border:0;width:88px;height:31px" />
            </a><br /><br /><br />
            <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
             style="border: 0; width: 125; height: 37;"
	     alt="SourceForge.net Logo" /></a>
          </td>
        </tr>
      </table></td>
    <td> <table width="100%"  border="0" cellspacing="1" cellpadding="0" 
          class="main">
        <tr>
          <td class="heading">&nbsp;&nbsp;&middot;&nbsp;
	    <a href="http://phantasmal.sf.net/DGD">DGD Page</a> &gt;
	    <a href="http://phantasmal.sf.net/DGD/LibWriting">MUDLibs</a> &gt;
            <a href="">Player vs Body</a>
          </td>
        </tr>
        <tr>
          <td class="content">
  

  <h2> Separating Player LPC Objects from Body Objects </h2>

  <p>
    It's possible to separate a player's in-game presence into many
    LPC objects, or few.  You can have separate LPC objects for the
    player, the network connection, the mobile (Skotos uses the phrase
    'combat brain' to refer to this object) and the material body, or
    you can combine any or all of them to get fewer objects, or just a
    single object.
  </p>

  <p>
    Melville separates the player&frasl;user&frasl;connection object
    from the physical body object.  Phantasmal goes a step further and
    separates out the idea of a mobile into its own object.  These
    methods make it possible to do tricks like swapping bodies more
    easily, and to otherwise reassign network connections, at the cost
    of more files, and perhaps more complexity, in the player data.
    Swapping bodies is particularly useful for wizards to test NPCs
    and impersonate others.  The TMI-2 MUDLib uses a similar trick for
    dead PCs having ghost bodies.
  </p>

  <p>
    Phantasmal separates the mobile object out specifically to more
    easily allow NPC actions and player actions to share code.  By
    making player actions &quot;more like&quot; NPC actions, the same
    functions can operate for both.  Skotos does a similar thing with
    their action&frasl;verb separation.
  </p>

  <p>
    In DGD, it's often useful to separate the player's presence into
    multiple objects because the connection object is transient and
    goes away when the user disconnects &mdash; DGD will destroy the
    network connection object on disconnection.  However, the player
    data can be stored in other in-game objects.  By simply keeping
    those objects in existence and attaching them to a new connection
    object, you can maintain any modifications to them while never
    saving them to outside-the-MUD storage.
  </p>

  <h3> Reassigning Connections </h3>

  <p>
    In DGD, there is a single connection object that DGD recognizes as
    representing any single network connection.  DGD doesn't have
    specific support for reassigning input from one connection to
    another, so you're usually better off separating the connection
    into its own object and having a way (in the other, non-connection
    objects) to reassign what connection's input goes where.  Why not
    have the driver do it?  Because DGD has the philosophy that
    nothing that can be easily done in LPC can be done in the driver.
    The Kernel Library does the reassignment trick, so obviously it
    can be done in LPC.
  </p>

  <h3> Efficiency </h3>

  <p>
    So does all this dividing stuff into objects waste a lot of space?
    Well, it'll waste part of a sector for each object, at least if
    the resulting objects are small.  So that will probably cost you
    on the order of a kilobyte for each connected player in your MUD.
    So if you have one of the most popular MUDs on the internet, with
    about a thousand players connected at peak, this will cost you
    about...  a megabyte of memory.  And that's assuming you're doing
    a fair amount of dividing up objects.  Consider whether it's worth
    the difference in features and maintainability, but the memory
    usage isn't a significant difference.
  </p>

<pre>
From: DGD Mailing List (Par Winzell)
Date: Wed Mar 24 09:18:01 2004
Subject: [DGD] Aliases & Stacked commands

Bart van Leeuwen wrote:

> I think you really want something like this_player() because 'users' are
> not the only livigns that can use 'commands' on your average mud, which
> means to me that commands should never ever depend on this_user() since
> they will fail when used by a living thats not linked to any user.
> Of course there can be exceptions for security reasons, but those are
> cases where runnign such a command from an alias would not be a good idea
> either I believe.

I certainly agree that a living object should not depend on having a 
connected user for any of its in-world actions. In Skotos we separated 
commands and actions entirely -- commands belong to the text interface 
layer, actions are in the virtual world. Commands cause actions. NPC 
brains cause actions.

We deliberately rejected this_player(), though. As I recall, half of the 
  code in the old LPC driver is concerned with making sure this_player() 
has the right value at all times. It needs to be switched in and out 
constantly, depending on which function is being called where.

Instead, we simply pass along an explicit 'actor' variable.

As concerns this_user(), I ended up implementing a query_originator(), 
which is a version of this_user() that is persisted across call_outs. 
Originally this change was motivated by the fact that LPC is single 
threaded, and thus anything that touches the network has to use a 
callback approach to waiting for responses. Obviously, DGD's idea of 
this_user() does not survive that kind of 'wait', and so we wrote a 
bunch of infrastructure to bridge the gap. The main purpose was for 
runtime error reporting to continue arriving at the originating 
connection even after the callback.

Later, we've had to spread more and more processes out into 
callout-driven background processes. It's nice to have runtime error 
reporting continue to function there, too.

Zell
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
            <address>
            <span><a href="mailto:angelbob-remove-spamfree@spamfree.users.sf.net">Noah Gibbs</a></span>
            </address></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
