  <titledef text="LWOs and Swapping" />

  <h2> Using Regular DGD Objects and LWOs &mdash; Swapping Behavior </h2>

  <p>
    Before dealing specifically with LWOs, make sure you understand
    DGD's <a href="Swapping.html">normal swapping behavior</a>.
  </p>

  <p>
    An LWO is an object whcih is 'embedded' in another DGD object.
    Regular DGD objects swap as usual, but an LWO swaps as part of
    another object's data.  When the LWO's 'parent' object (not in an
    inheritance sense, but in the sense of whose data space contains
    references to it) is swapped out, so is the LWO.  The LWO doesn't
    get its own sectors in the swapfile.  Instead, the LWO is part of
    the space taken up by its host object.
  </p>

  <p>
    Like an array or mapping, an LWO is copied if an object (other
    than its host object) has a reference to it at the end of a thread
    of execution.  That is, the LWO is referenced by more than one
    regular DGD object for <i>no longer</i> than one thread of
    execution.  After that, it is copied.  Be careful passing
    references to LWOs around for this reason &mdash; you don't want
    duplicate copies, which are large, wasteful and may cause data
    inconsistencies.
  </p>

  <p>
    Like arrays or mappings, LWOs are garbage collected, so when the
    last reference to them disappears, so do they.  This is true even
    in circular structures.  LWOs may not be explicitly destructed.
  </p>

  <p>
    LWOs cannot be used as an editor, user or parser object, nor can
    they have callouts.  It is not clear (to me, right this second)
    whether a parse_string() call in an LWO will store its generated
    automaton cache in the LWO or the host heavyweight DGD object.  If
    the master object of an LWO is destructed, the LWO is destroyed as
    well, along with all others created from that master object.
  </p>

  <p>
    If you've been looking for structures in DGD, LWOs fill roughly
    that need.
  </p>

<pre>
From: DGD Mailing List (Par Winzell)
Date: Tue Mar 19 15:01:00 2002
Subject: [DGD] Memory management

>>I probably just need a pointer in the right direction, but I'm getting a 
>>bit confused on DGD's memory  management.
>>
>>My impression was that DGD used a reference counting scheme to free up 
>>objects that no longer had references, similar to Java's garbage collection.
>>
> 
> [...]
> 
>>What am I missing?
> 
> There are two types of objects, persistent (regular) objects, and the
> so-called lightweight objects a.k.a LWOs.  LWOs are created using the
> new_object() kfun and will disappear automatically, whereas regular
> objects are created using compile_object() for standalone objects and
> clone base-objects, clone_object() for clones, and zapped into
> oblivion using destruct_object().

To expand on this: for persistent objects (which is all you'll see in 
the kernel library) the references to the object are of no consequence; 
when the object is destructed, any existing reference to the object will 
evaluate to 'nil'. In a multi-programmer environment like your average 
LPMud, this is more than practical, it is more or less a requirement -- 
if every sloppy left-over reference could keep an object alive, there 
would be accrue vast unfreed and unused object structures in memory over 
the years.

As it is, this 'destruction' scheme allows you to go occasionally slowly 
sift through all the potentially millions of objects and crudely put the 
obsolete ones to death, automatically castrating any existing references 
to them.

Zell
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
