  <titledef text="Persistent MUDLibs" />

  <h2> Persistent MUD Libraries &mdash; Yes or No? </h2>

  <p>
    DGD has changed a lot from its conceptual roots in LPMUD.  The
    language is very different, the server features are very
    different.  One of the visions that has driven some of DGD's most
    powerful and unusual features is persistence.  Persistence makes a
    major difference in a MUD library, and you'll need to decide early
    on whether you want to take the effort to support it.
  </p>

  <p>
    Note that if you <i>do</i> decide to use persistence, the <a
    href="../Kernel">Kernel Library</a> is worth a second look.  It
    includes extra support for a lot of the issues that persistence
    can cause your MUD.
  </p>

  <h3> DGD's Definition </h3>

  <p>
    You'll hear the phrase 'persistent MUD' batted around a lot, and
    'persistent world' batted around even more often.  It can mean any
    of several different things.  The DGD community talks about DGD
    providing excellent support for a persistent MUD.  What do they
    mean by it?
  </p>

  <p>
    Some of them are referring to the game design.  However, DGD can't
    support your game design.  <a
    href="GamePersistence.html">Persistent game design</a> is a
    different topic.
  </p>

  <p>
    Primarily, they mean that the game runs as though it would never
    shut down, and as though the server never went down, even if the
    server <i>will</i> go down.  The game, as a single run of the
    program, never stops and rarely even pauses.  DGD's definition of
    Persistence involves being able to keep actual LPC-language
    objects around, potentially forever.  The object pointers never
    expire, you never have to save or restore, you never need to write
    code to back up your objects &mdash; because conceptually, the
    server never, never goes down.
  </p>

  <h3> DGD Support </h3>

  <p>
    If you're never going to shut the server down, you need the
    ability to <a href="ObjectManagement.html">upgrade in place</a>.
    Eventually you'll want to add new features, new content, new code.
    Since you're never going to stop your current run of the program,
    you'll need to deploy all that immediately, preferably without
    even logging your players out.  DGD allows you to do this.
  </p>

  <p>
    The way it implements this goal is the <a
    href="StateDumps.html">State Dump</a>.  A State Dump dumps a copy
    of all your LPC objects, whether in memory or swapped out, with
    all connections between them, to a file.  You may then, later,
    start DGD from that State Dump file and it will pick up precisely
    where it left off.  There are a (very) few things that necessarily
    change (the time and date, what network connections are active),
    but mostly this keeps all objects around forever.  When you
    restore from a dump, it just looks like the clock skipped (or you
    took awhile to run the next thread of execution) and all the
    network connections suddenly dropped, which is effectively what
    happened.
  </p>

  <p>
    Doing this requires a <a href="Cleanup.html">object cleanup</a>
    solution.  You need to be able to find old objects that are no
    longer in use and destruct them.  An object leak will eventually,
    over weeks or years, bring your MUD down because old leaked
    objects will never go away.  Rebooting no longer helps because all
    your old objects will stick around across reboots (if you use the
    State Dump, that is).
  </p>

  <p>
    But that curse is also a disguised blessing.  You can save a lot
    of code if you don't need to rebuild all your object structures
    when you reboot.  You no longer need to write your data to disk.
    If you make a change in an object, it stays around even if you
    don't have a way to turn that change into a data file.  That can
    be a big, big change.
  </p>

  <p>
    Normally, keeping all of this in RAM would mean using a ridiculous
    amount of memory.  However, DGD is a disk-based server, and
    believes very strongly in <a href="Swapping.html">swapping things
    to disk</a> constantly to save your memory.  This means that if
    you store data as LPC objects in memory, they wind up taking no
    more memory or disk space than if you saved all idle objects to
    disk.  But you can access them instantly as LPC objects in memory,
    and DGD will transparently handle all swapping.
  </p>

  <h3> Persistence and Player Bodies </h3>

  <p>
    Persistence is also related to <a href="PlayerBody.html">how you
    choose to represent the player</a> in your MUD.  Whether the
    player's body is represented by a single monolithic object or
    separated into a body and a connection object determines whether
    you can simply keep the player's body in memory when it's not
    connected.  Note that you don't have to keep the body visible to
    keep the body's LPC object stored somewhere in memory.
  </p>

  <p>
    This also affects how equipment may be stored.  A player's
    equipment can be kept with his body, including any customizations.
    The MUD would simply move it to an unused or virtual room, if the
    body persists anyway.  Doing so is optional, of course, but it's
    another form of saving-to-file that can be avoided with a
    persistent MUD if the implementor so desires.
  </p>

  <p>
    You'll need to periodically delete unused players if you need to
    free up space, just like you'd have to with player files.  You'll
    need to list all players and determine whether they've been idle
    so long that they need to be deleted.  That's probably easier if
    the players are stored as in-memory LPC objects rather than
    needing to be parsed from data files.
  </p>

  <h3> Upgrading Existing Objects </h3>

  <p>
    A problem with upgrading in-place is that if you change certain
    parts of how your LPC objects work, you'll be left with a lot of
    LPC data that works the old way, not the new way.  If you can save
    and restore then it's possible to write a datafile adapter and
    kludge around this.  The equivalent for a persistent MUD is an
    update function.
  </p>

  <p>
    To upgrade objects, you'll already need to have object management
    code to rebuild files.  Your object manager can also call upgrade
    functions on master objects easily, and those master objects can
    track and upgrade clones.  If you're using the Kernel Library,
    it's also possible to track clones by owner with the ObjRegD, or
    you can roll your own tracking system.
  </p>

  <p>
    In any case, it's sometimes necessary to write code to initialize
    new fields (such as one you just added), or move data from old
    fields into new ones.  It's not harder than writing a datafile
    converter that does the same thing, but the results can be
    trickier if you do it wrong.  Remember, in this case you're
    updating live data and you may have players connected at the time.
    Backing up first is a useful thing, and it may be useful to start
    a secondary 'test' server from a live statedump and try your
    upgrade code there first to make sure it works.
  </p>

  <p>
    You may also find that it's useful to do an upgrade in stages.
    For instance, if you change the type and representation of a field
    in an LPC object, you may want to add the new one, put the data
    into its new location, then do a <i>second</i> LPC upgrade to
    remove the old field.
  </p>

  <h4> Example </h4>

  <p>
    For instance, I might change my objects to stop storing a
    &quot;brief description&quot; string and instead store offsets
    into my arrays of nouns and adjectives to make a description.  So
    if you see a &quot;broad green tabard&quot; then you're guaranteed
    you can &quot;look broad green tabard&quot; since it uses nouns
    and adjectives in the object.
  </p>

  <p>
    However, when I take add the new data field (let's say an array of
    integer offsets, so it'll be an int pointer), I'll need to fill in
    decent values.  I could make it default to saying the first two
    adjectives, then the first noun.  So I'd set the array to <tt>[0,
    1, 0]</tt>, where the last element is the offset into the array of
    nouns.
  </p>

  <p>
    So far, so good.  But where do I put the code to fill in all those
    fields?  One answer is &quot;in the ObjectD&quot;.  My favorite
    answer is to have the ObjectD call a function called
    &quot;upgraded&quot; if it exists on every object that gets
    upgraded.  That's what Phantasmal does.
  </p>

  <p>
    So I could put that code I mentioned above into the upgraded()
    function of my object type, then type &quot;%full_recompile&quot;
    at the command line, and my objects would all start being
    described as &quot;big brown table&quot; and &quot;flat checkered
    floor&quot; and things, all according to the first nouns and
    adjectives on their current lists.  Then I'd go fix all the descs,
    'cause that would look funny :-)
  </p>

  <p>
    But I've had to write specific upgrade code for the specific
    change I made to my objects.  In a standard MUD, I'd make the
    change to the object loading code, then shutdown the MUD and
    restart it.  Then all my objects would be appropriately altered,
    but I'd also have to drop everybody's network connection to do it,
    and generally disrupt things.  Not nearly as convenient.  Plus,
    it's slow to do all that loading and saving of LPC objects using
    LPC code.  Much faster to use a statedump.
  </p>

  <h3> Why No Load and Save? </h3>

  <p>
    If you use statedumps, there's no reason to ever move things out
    of memory, usually.  You'll need backups, but statedumps are
    (under DGD) the fastest available backups if you're writing out
    most of your MUD's data.  That saves you having to write code for
    reading and writing objects, and more importantly for large
    interconnected systems of objects.
  </p>

  <p>
    You may choose to have object load&frasl;save code anyway,
    probably for object import&frasl;export.  Skotos and Phantasmal
    both do this.  However, object saving is slow compared to
    statedumps, so normally object saving will only be used for
    export to a different MUD or different program.
  </p>

  <h3> Can't This All Be Done Without DGD? </h3>

  <p>
    Certainly.  A shovel's not the only way to dig a hole - you can
    use a spoon, if you're so inclined.  You can write a large amount
    of code to save and restore huge interconnected systems of
    objects.  You can do the years (almost decades, now) of testing
    that DGD has already received on those systems, and do it all for
    yourself.  None of this is impossible &mdash; DGD itself is
    written in C, so obviously a C-based system will do all of this
    just fine if it's designed correctly.
  </p>

  <p>
    Now:  have you asked yourself why you'd ever want to?
  </p>

<pre>
Note:  Some messages modified


From dgd at list.imaginary.com  Thu Jan  8 14:43:00 2004
From: dgd at list.imaginary.com (Noah Gibbs)
Date: Thu Jan  8 14:43:00 2004
Subject: [DGD] Persistance
In-Reply-To: <BAY10-F96EKOEoY2Lku0004114f@hotmail.com>
Message-ID: <20040108204243.44477.qmail@web12823.mail.yahoo.com>

--- Robert Forshaw <iouswuoibev@hotmail.com> wrote:
> When you eventually do reboot, how will it
> reconnect the rooms? Doing it by 
> file name makes this easy, but by object
> reference, well, for a start every 
> room object will have to be loaded, and then
> how is it going to figure out 
> what rooms connect to where, if not by file
> name?
 
  Here's a clarification that may help.  Under Unix,
there's something called a core dump.  Conceptually,
it's kind of like a DGD statedump.  The idea is that
the process's memory is all written out, along with
*all* its state, into a big file.  That file contains
the entire application in exactly the state it was in
when it core dumped.

  Usually, coredumps are used for debugging.  But
certain very clever applications use them for other
purposes.  For instance, emacs and some Perl
applications use them for compiling.  They go through
a very long startup sequence (several hours for
emacs), and then the dump core *without* crashing.

  When you run emacs, or run a precompiled Perl
binary, what happens is that core dump gets loaded
right back into memory, in the exact state where it
dumped core.  From the newly-loaded app's point of
view, it just dumped core and now it's time to run. 
Every time you run the app, you're restoring from its
just-after-build application state, without having to
wait for hours of startup while it compiles many
megabytes of code.

  DGD statedumps work a lot like coredumps.  All your
current running code is dumped.  All your objects are
dumped.  All your data is dumped.  All the stuff in
the swapfile is dumped.

  And when you put it back, it's as though it had
never been gone.  If you have a chunk of code which
contains a statedump, you won't know on the line after
that statedump if you just breezed through it, or if
you've just been restored, minutes or weeks or decades
later, from that statedump.  Maybe all your net
connections just went down (they do that when you
restore years later, alas).  Maybe your system clock
just advanced by a couple of weeks.  It's hard to
tell.  Because your function will continue just fine
ten years later, and may *not even realize* that you
just dumped state and restarted.

  I'm exaggerating slightly.  I think the statedump
happens just after the thread exits.  But when the
call_out that you scheduled ten years ago happens, it
won't know that it was scheduled ten years ago.  It'll
just know that it's time to run again :-)

=====
------
noah_gibbs@yahoo.com

</pre>

<p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
