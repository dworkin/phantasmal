  <titledef text="Persistent MUDLibs" />

  <h2> Persistent MUD Libraries &mdash; Yes or No? </h2>

  <p>
    DGD has changed a lot from its conceptual roots in LPMUD.  The
    language is very different, the server features are very
    different.  One of the visions that has driven some of DGD's most
    powerful and unusual features is persistence.  Persistence makes a
    major difference in a MUD library, and you'll need to decide early
    on whether you want to take the effort to support it.
  </p>

  <p>
    If you <i>do</i> decide to use persistence in a DGD MUDLib, the <a
    href="../Kernel">Kernel Library</a> is worth a second look.  It
    includes extra support for a lot of the issues that persistence
    can cause your MUD.
  </p>

  <h3> DGD's Definition </h3>

  <p>
    You'll hear the phrase 'persistent MUD' batted around a lot, and
    'persistent world' batted around even more often.  It can mean any
    of several different things.  The DGD community talks about DGD
    providing excellent support for a persistent MUD.  What do they
    mean by it?
  </p>

  <p>
    The phrases often refer to the game design.  However, DGD can't
    dictate your game design.  <a
    href="GamePersistence.html">Persistent game design</a> is a
    different topic.
  </p>

  <p>
    Primarily, the DGD community means that the game runs as though it
    would never shut down, and as though the server never went down,
    even if the server <i>will</i> go down.  The game, as a single run
    of the program, never stops and rarely even pauses.  DGD's
    definition of Persistence involves being able to keep actual
    LPC-language objects around, potentially forever.  The object
    pointers never expire, you never have to save or restore, you
    never need to write code to back up your objects &mdash; because
    conceptually, the server never, never goes down.
  </p>

  <h3> DGD Support </h3>

  <p>
    If you're never going to shut the server down, you need the
    ability to <a href="ObjectManagement.html">upgrade your LPC
    objects in place</a>.  Eventually you'll want to add new features,
    new content, new code.  Since you're never going to stop your
    current run of the program, you'll want to deploy all that
    immediately, preferably without even logging your players out.
    DGD allows you to do this.
  </p>

  <p>
    One way DGD simulates a single continuous run of the program is
    the <a href="StateDumps.html">State Dump</a>.  A State Dump dumps
    a copy of all your LPC objects, whether in memory or swapped out,
    with all connections between them, to a file.  You may then,
    later, start DGD from that State Dump file and it will pick up
    precisely where it left off.  There are a (very) few things that
    necessarily change (the time and date, what network connections
    are active), but mostly this keeps all objects around forever.
    When you restore from a dump, it just looks like the clock skipped
    (or you took awhile to run the next thread of execution) and all
    the network connections suddenly dropped, which is effectively
    what happened.
  </p>

  <p>
    Keeping a single run of the program going for so long requires a
    <a href="Cleanup.html">object cleanup</a> solution.  You need to
    be able to find old objects that are no longer in use and destruct
    them.  Over days, weeks or years, an object leak will eventually
    bring your MUD down because old leaked objects will never go away.
    Rebooting no longer helps because all your old objects will stick
    around across reboots.
  </p>

  <p>
    But that curse is also a disguised blessing.  You can save a lot
    of code if you don't need to rebuild all your object structures
    when you reboot.  You no longer need to write your data to disk.
    If you make a change in an object, it stays around even if you
    don't have a way to write that change to a data file.  That can be
    a big, big change in the way you think about your MUD Library.
  </p>

  <p>
    Normally, keeping all of your objects in RAM at all times would
    mean using a ridiculous amount of memory.  However, DGD is a
    disk-based server, and believes very strongly in <a
    href="Swapping.html">swapping things to disk</a> constantly to
    save memory.  This means that if you store data as LPC objects,
    they wind up taking no more memory or disk space than if you saved
    idle objects to disk.  But you can access them instantly as LPC
    objects in memory, and DGD will transparently handle all swapping.
  </p>

  <h3> Persistence and Player Bodies </h3>

  <p>
    Persistence is also related to <a href="PlayerBody.html">how you
    choose to represent the player</a> in your MUD.  Whether the
    player's body is represented by a single monolithic object or
    separated into a body and a connection object determines whether
    you can simply keep the player's body in memory when it's not
    connected.  Note that you don't have to keep the body visible
    in-game to keep the body's LPC object stored somewhere in memory.
  </p>

  <p>
    This also affects how equipment may be stored.  A player's
    equipment can be kept with his body, including any customizations.
    The MUD would simply move it to an unused or virtual room, if the
    body persists anyway.  Doing so is optional, of course, but it's
    another form of saving-to-file that can be avoided with a
    persistent MUD if the implementor so desires.  If your MUD permits
    object customization, this can be a way to save it long-term.
  </p>

  <p>
    You'll need to periodically delete unused players if you need to
    free up space, just like you'd have to with player files.  You'll
    need to list all players and determine whether they've been idle
    so long that they need to be deleted.  That's probably easier if
    the players are stored as in-memory LPC objects rather than
    needing to be parsed from data files.
  </p>

  <h3> Upgrading Existing Objects </h3>

  <p>
    A problem with upgrading in-place is that if you change certain
    parts of how your LPC objects work, you'll be left with a lot of
    LPC data that works the old way, not the new way.  If you can save
    and restore then it's possible to write a datafile adapter and
    kludge around this.  The equivalent for a persistent MUD is an
    update function.
  </p>

  <p>
    To upgrade objects, you'll already need to have object management
    code to rebuild files.  Your object manager can also call upgrade
    functions on master objects easily, and those master objects can
    track and upgrade clones.  If you're using the Kernel Library,
    it's also possible to track clones by owner with the ObjRegD, or
    you can roll your own tracking system.
  </p>

  <p>
    In any case, it's sometimes necessary to write code to initialize
    new fields (such as one you just added), or move data from old
    fields into new ones.  It's not harder than writing a datafile
    converter that does the same thing, but the results can be
    trickier if you do it wrong.  Remember, in this case you're
    updating live data and you may have players connected at the time.
    Backing up first is a useful thing, and it may be useful to start
    a secondary 'test' server from a live statedump and try your
    upgrade code there first to make sure it works.
  </p>

  <p>
    You may also find that it's useful to do an upgrade in stages.
    For instance, if you change the type and representation of a field
    in an LPC object, you may want to add the new one, put the data
    into its new location, then do a <i>second</i> LPC upgrade to
    remove the old field.
  </p>

  <h4> Example </h4>

  <p>
    For instance, I might change my objects to stop storing a
    &quot;brief description&quot; string and instead store offsets
    into my arrays of nouns and adjectives to make a description.  So
    if you see a &quot;broad green tabard&quot; then you're guaranteed
    you can &quot;look broad green tabard&quot; since it uses nouns
    and adjectives in the object.
  </p>

  <p>
    However, when I take add the new data field (let's say an array of
    integer offsets, so it'll be an int pointer), I'll need to fill in
    decent values.  I could make it default to saying the first two
    adjectives, then the first noun.  So I'd set the array to <tt>[0,
    1, 0]</tt>, where the last element is the offset into the array of
    nouns.
  </p>

  <p>
    So far, so good.  But where do I put the code to fill in all those
    fields?  One answer is &quot;in the ObjectD&quot;.  My favorite
    answer is to have the ObjectD call a function called
    &quot;upgraded&quot; if it exists on every object that gets
    upgraded.  That's what Phantasmal does.
  </p>

  <p>
    So I could put that code I mentioned above into the upgraded()
    function of my object type, then type &quot;%full_recompile&quot;
    at the command line, and my objects would all start being
    described as &quot;big brown table&quot; and &quot;flat checkered
    floor&quot; and things, all according to the first nouns and
    adjectives on their current lists.  Then I'd go fix all the descs,
    'cause that would look funny :-)
  </p>

  <p>
    But I've had to write specific upgrade code for the specific
    change I made to my objects.  In a standard MUD, I'd make the
    change to the object loading code, then shutdown the MUD and
    restart it.  Then all my objects would be appropriately altered,
    but I'd also have to drop everybody's network connection to do it,
    and generally disrupt things.  Not nearly as convenient.  Plus,
    it's slow to do all that loading and saving of LPC objects using
    LPC code.  Much faster to use a statedump.
  </p>

  <h3> Why No Load and Save? </h3>

  <p>
    If you use statedumps, there's no reason to ever move things out
    of memory, usually.  You'll need backups, but statedumps are
    (under DGD) the fastest available backups if you're writing out
    most of your MUD's data.  That saves you having to write code for
    reading and writing objects, and more importantly for large
    interconnected systems of objects.
  </p>

  <p>
    You may choose to have object load&frasl;save code anyway,
    probably for object import&frasl;export.  Skotos and Phantasmal
    both do this.  However, object saving is slow compared to
    statedumps, so normally object saving will only be used for
    export to a different MUD or different program.
  </p>

  <h3> Can't This All Be Done Without DGD? </h3>

  <p>
    Certainly.  A shovel's not the only way to dig a hole - you can
    use a spoon, if you're so inclined.  You can write a large amount
    of code to save and restore huge interconnected systems of
    objects.  You can do the years (almost decades, now) of testing
    that DGD has already received on those systems, and do it all for
    yourself.  None of this is impossible &mdash; DGD itself is
    written in C, so obviously a C-based system will do all of this
    just fine if it's designed correctly.
  </p>

  <p>
    Now:  have you asked yourself why you'd ever want to?
  </p>

<p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
