<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DGD and LPC: Object Management</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../../phantasmal.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="95%" border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td colspan="2"> <table width="100%" border="0" cellspacing="1"
        cellpadding="0" class="main">
        <tr>
          <td class="banner">The DGD Driver</td>
        </tr>
      </table></td>
  </tr>
  <tr>
    <td valign="top">
      <table width="25%"  border="0" cellspacing="1"
             cellpadding="0"  class="main">
        <tr>
          <td class="content" style="font-size: 120%">

          <ul style="margin: 0; padding-left: 10%">
            <li> <a href="index.html">DGD &amp; LPC Page</a> </li>
	    <li> <a href="../LPC">LPC Textbook</a> </li>
	    <li> <a href="../Book">New LPC Introduction</a> </li>
          </ul>

        </td>
        </tr>
        <tr>
          <td class="content" align="center">
            <a href="http://validator.w3.org/check/referer">
            <img src="../../images/valid-xhtml10.gif" alt="Valid XHTML 1.0!"
             style="border:0;width:88px;height:31px" /></a><br />
            <img src="../../images/pixel.gif"
             style="border:0;width:88px;height:1px" alt="" /><br />
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
            <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!" style="border:0;width:88px;height:31px" />
            </a><br /><br /><br />
            <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
             style="border: 0; width: 125; height: 37;"
	     alt="SourceForge.net Logo" /></a>
          </td>
        </tr>
      </table></td>
    <td> <table width="100%"  border="0" cellspacing="1" cellpadding="0" 
          class="main">
        <tr>
          <td class="heading">&nbsp;&nbsp;&middot;&nbsp;
	    <a href="http://phantasmal.sf.net/DGD">DGD Page</a> &gt;
            <a href="">Object Management</a>
          </td>
        </tr>
        <tr>
          <td class="content">
  

  <h2> Managing and Upgrading DGD Objects </h2>

  <p>
    DGD is impressive in the degree of upgradeability and <a
    href="Persistence.html">persistence</a> that it offers.  However,
    to take full advantage of the upgradeability, you'll need to
    observe some ground rules.
  </p>

  <p>
    DGD's <a href="../Kernel/Inheritance.html">inheritance</a>
    features aren't quite the same as a regular LPMUD, though they're
    far more powerful if used correctly.
  </p>

  <p>
    You'd like to be able to upgrade all your code while leaving your
    data in place.  For instance, you'd like to be able to write a new
    feature for your MUD, and enable it while players are logged in.
    Before the recompile, the feature isn't there.  After the
    recompile, it is.  Players don't see any difference until they try
    the new command, which works after the recompile.  This is less of
    a pipe-dream than it sounds.  <a
    href="http://phantasmal.sf.net">Phantasmal</a> already does it
    using the %full_rebuild command, and the Kernel Library has a less
    automated, more awkward way to do it, but it can work.  Sadly, few
    other DGD libraries (except the closed-source <a
    href="http://www.skotos.net">Skotos</a> servers) seem to do this.
  </p>

  <p>
    One reason that few libraries bother to do this is that it
    requires tracking all object compilation and inheritance.  The
    Kernel Library makes this slightly easier by encapsulating that
    functionality into an Object Manager (see the LPC Examples section
    for several Object Managers, or download Phantasmal and look at
    that one).
  </p>

  <p>
    There are some other related tricks you can do.  It's usually very
    convenient to call a function on objects that are recompiled but
    also have data.  The data may need to be updated after the change
    in code.  Phantasmal calls an &quot;upgraded&quot; function in any
    recompiled master object, if it exists (if clones or LWOs need to
    be updated, the master must keep a list of them or they must be
    looked up using the Kernel Library tracking facilities).  <a
    href="http://www.skotos.net">Skotos'</a> libraries use a different
    method based on the call_touch kfun to update objects as they are
    used.  This makes a great deal of sense, given the quantities of
    objects that Skotos' libraries deal with.
  </p>

  <p>
    As a random aside, remember that an object isn't compiled until
    the end of the thread where compile_object() gets called.  So
    there are some subtle issues about what version of the
    &quot;upgraded&quot; function gets called.  The old one, already
    compiled into the object?  The new one, the one that isn't
    currently compiled?
  </p>

  <p>
    John &quot;West&quot; McKenna's Inferno library has a
    significantly more complex approach, which allows for more
    interesting upgrades in some cases.  Its upgrader builds a list of
    objects that need recompiling.  It calls uninit() on them, then
    upgrading().  Then it recompiles, then calles upgraded() and
    finally init().
  </p>

  <p>
    The uninit() and init() functions are expected to do everything
    that's required when an object moves from one place to another
    except the actual move.  This includes removing&frasl;adding
    commands defined by the object from&frasl;to the user's grammar
    table.
  </p>

  <p>
    upgrading() and upgraded() are very rarely used.  They're there in
    case the new version of the code needs extra initialising.
  </p>

  <p>
    The Kernel Library uses what's called an <a
    href="../Kernel/ObjectManager.html">Object Manager</a>, or
    ObjectD, to do all of this.  That doesn't change what you can do,
    but it does alter some of the code.
  </p>

<pre>
From dgd at list.imaginary.com  Sat Feb 16 08:30:01 2002
From: dgd at list.imaginary.com (Erwin Harte)
Date: Sat Feb 16 08:30:01 2002
Subject: [DGD] Object recompiled when objectd calls compile()?
In-Reply-To: <Pine.BSF.4.21.0202152334220.39358-100000@hoot.monkeyspeak.com>
References: <Pine.BSF.4.21.0202152334220.39358-100000@hoot.monkeyspeak.com>
Message-ID: <20020216140645.GS1336@kansas.is-here.com>

On Fri, Feb 15, 2002 at 11:44:39PM -0800, Noah Lee Gibbs wrote:
>   Hi.  I'm having an odd problem with my objectd, and I'm hoping one of
> you folks will have an idea how to solve it...
> 
>   My objectd will call an upgraded() method on an object being recompiled
> if one exists.  That's all well and good.
> 
[...]
> 
>   Short of having a call_out to call upgraded, does anybody here know a
> good way to have an upgraded() method call the new version of the function
> instead of the old one?  I've been recompiling twice when I care about the
> contents of the upgraded function as a workaround, but it gets tedious...

No, as far as I'm aware a call_out(..., 0) is the best approach for
that, _re_compiled code doesn't go into effect until the thread has
finished.  This may seem silly now but what if you're recompiling the
very object you are currently calling a function in?

Hope that helps,

Erwin.
-- 
Erwin Harte <harte@xs4all.nl>
</pre>

<hr />

<pre>
From dgd at list.imaginary.com  Sat Feb 16 10:10:01 2002
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Sat Feb 16 10:10:01 2002
Subject: [DGD] Object recompiled when objectd calls compile()?
Message-ID: <200202161545.QAA12308@dworkin.nl>

Erwin Harte <harte@xs4all.nl> wrote:

> On Fri, Feb 15, 2002 at 11:44:39PM -0800, Noah Lee Gibbs wrote:
> [...]
> > 
> >   Short of having a call_out to call upgraded, does anybody here know a
> > good way to have an upgraded() method call the new version of the function
> > instead of the old one?  I've been recompiling twice when I care about the
> > contents of the upgraded function as a workaround, but it gets tedious...
>
> No, as far as I'm aware a call_out(..., 0) is the best approach for
> that, _re_compiled code doesn't go into effect until the thread has
> finished.  This may seem silly now but what if you're recompiling the
> very object you are currently calling a function in?

Furthermore, suppose that you are recompiling several objects that
depend upon eachother.  If each recompilation goes into effect instantly,
things might go wrong before the last one can be recompiled.

Regards,
Dworkin
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
            <address>
            <span><a href="mailto:angelbob-remove-spamfree@spamfree.users.sf.net">Noah Gibbs</a></span>
            </address></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
