<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DGD and LPC: Rlimits</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../../phantasmal.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="95%" border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td colspan="2"> <table width="100%" border="0" cellspacing="1"
        cellpadding="0" class="main">
        <tr>
          <td class="banner">The DGD Driver</td>
        </tr>
      </table></td>
  </tr>
  <tr>
    <td valign="top">
      <table width="25%"  border="0" cellspacing="1"
             cellpadding="0"  class="main">
        <tr>
          <td class="content" style="font-size: 120%">

          <ul style="margin: 0; padding-left: 10%">
            <li> <a href="index.html">DGD &amp; LPC Page</a> </li>
	    <li> <a href="../LPC">LPC Textbook</a> </li>
	    <li> <a href="../Book">New LPC Introduction</a> </li>
          </ul>

        </td>
        </tr>
        <tr>
          <td class="content" align="center">
            <a href="http://validator.w3.org/check/referer">
            <img src="../../images/valid-xhtml10.gif" alt="Valid XHTML 1.0!"
             style="border:0;width:88px;height:31px" /></a><br />
            <img src="../../images/pixel.gif"
             style="border:0;width:88px;height:1px" alt="" /><br />
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
            <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!" style="border:0;width:88px;height:31px" />
            </a><br /><br /><br />
            <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
             style="border: 0; width: 125; height: 37;"
	     alt="SourceForge.net Logo" /></a>
          </td>
        </tr>
      </table></td>
    <td> <table width="100%"  border="0" cellspacing="1" cellpadding="0" 
          class="main">
        <tr>
          <td class="heading">&nbsp;&nbsp;&middot;&nbsp;
	    <a href="http://phantasmal.sf.net/DGD">DGD Page</a> &gt;
            <a href="">Rlimits</a>
          </td>
        </tr>
        <tr>
          <td class="content">
  

  <h2> Using rlimits() in your Library </h2>

  <p>
    The rlimits() DGD construct can be used to keep your MUD running
    despite infinite loops and infinite recursions in code.  In
    combination with status(), it can be used for profiling your code
    and keeping track of how much processor time each wizard, or each
    function, is taking up.
  </p>

<pre>
Message-Id: <199805202101.XAA10204@harte.xs4all.nl>
Date: Wed, 20 May 1998 23:01:05 +0200 (CEST)
From: harte@xs4all.nl
Subject: [DGD] Re: rlimits() question

Quoting your message from 20 May:

[...]
| ...how does one establish those defaults in the first
| place? I think that if one does nothing, the defaults are no
| limits, and if one wants to establish limits, one puts the code:
| 
|    rlimits {
|       stuff ;
|    }
| 
| someplace that every function call will encounter it. The question
| is, where does one put that? I imagine receive_message in the driver
| would work for anything generated by the user, but call_outs I'm
| less sure about. Do the rlimits that were in place when the call_out
| was invoked continue to apply when the call_out runs?

No, you'll have to put another rlimits() around the actual call.

By the way, 'rlimits' is technically not a kfun but part of the
language, similar to the 'catch' keyword.

Hope that helps,

Erwin.


Date: Wed, 20 May 1998 23:56:21 +0200 (MET DST)
From: Frank Schmidt <Frank.Schmidt@stud.idb.hist.no>
To: dgd@list.imaginary.com
Subject: [DGD] Re: rlimits() question


I'm sure you've looked in the README file for dgd-1.1, in the
changes-list. There it states that rlimits is a language
construct:

  rlimits (stackdepth; ticks) { code; }

Now it may be easier with an example, say you want to restrict
resources to a call from driver object with stackdepth 100 and
maximum ticksize 10000:

  rlimits (100, 10000) {
    call_other(USER, "any_function");
  }

As code there is no restriction how much you may put in it, as
long as it follows ANSI-C syntax to be put withinin a scope {...}.

If you want unlimited resources of any type, use -1 as argument,
for no change on a resource, use 0 as argument.

Now the difficulties begins, since there is no complete list over
functions called in different objects with unlimited resource-
limits (initially from the driver itself). *poke dworkin* 

I can sum all those functions I limited while creating MudOS-
alike for DGD. Though I haven't gotten the time to really test
them all, I'm sure I might have one too many or one too few:
  - ALL call_out calls
  - compile_error(), runtime_error(), remove_program() in DRIVER object
  - <create>() in AUTO object though restricting this is meaningless
  - <create>() in DRIVER object
  - receive_message() in USER object
  - open(), close() in USER object

very uncertain ones:
  - generally ALL new calls from the driver
  - rescue_file() in EDITOR object


Now, why restrict resources? Simply because you don't want the driver to
just hang on false code. Assume _your_ code is correct, but all calls to
user-defined code (out of your reach) should be limited and caught:

void sample_driver_func() {
  rlimit (100, 1000) {
    catch(call_other(master(), "check_privilege_or_whatever"));
  }
}

Why the catch? Well, it's cleaner, and it ensures _your_ code continues
to run even though the function the function called bugged/used too much
resources. 

Additionally try to avoiding resource-limiting your own drivercode,
since, well, functions handled closer to the driver should work okay and
thus you don't want bugs in code close to the driver just because the
current thread ran out of ticks.

Also, prevent over-use of rlimits adding on stackdepth and ticks. If the
function is called recursively, the limits are constantly reset/added,
thus the process might still hang.

Resource-limiting is a very important security issue, and is needed in an
environment with several users/implementators. It is vital to prevent
people from hanging the driver-process, even on purpose.


Personally I like to simplify things, and save me of the extra scope,
which tends to uglify things. So I did this:

/* default rlimits calls from driver objects */ 
#define RLIMITS_ON()   rlimits(DEFAULT_CALL_STACK ; DEFAULT_TICK_LIMIT) { 
#define RLIMITS_OFF()  } 

This means that in a close-to-driver-function I can just:

void sample_driver_func() {
  ...
  RLIMITS_ON();
  catch(call_other(master(), "check_privilege_or_whatever"));
  RLIMITS_OFF();
  ...
} 

This will set limits and catch just the calls that are "out of my 
hands" (even though I made the target functions too, they are user-
defined, and might be altered/inserted new bugs in)

Check out my package for an example on this and other stuff.


	Regards, 

	Frank Schmidt



Date: Sun, 27 May 2001 18:13:30 +0200
From: Erwin Harte <harte@xs4all.nl>
To: dgd@list.imaginary.com
Subject: Re: [DGD]Swap file?
Message-ID: <20010527181330.J10789@harte.xs4all.nl>

On Sun, May 27, 2001 at 04:53:02PM +0100, mtaylor wrote:
> Thanks everyone for help with everything so far.
> 
> As you can probably tell we are at that stage when all the little things we
> didn't know about jump us ;)
> 
> We are now getting this error when we log on two people to the Mud at the
> same time:
> 
> Fatal error: cannot create swap file "Macintosh HD:Dawn of Ages:tmp:swap"

I assume the HD exists, does the 'tmp' folder/directory exist?  DGD
will not automatically create it for you.  The only other thing that
comes to mind right now is that the harddisk could be filling up, or
that permissions are set incorrectly for the DGD process to create the
swap file, but I'm not familiar enough with the macintosh to guess.

> Help please :) 
> 
> We are running DGD 1.2 on a Macintosh. We have written our own mudlib from
> scratch so we may be missing things that we need.
> 
> Also with regards to rlimits. I don't really understand about threads and
> wondered if anyone could explain it easily to me. It's all about where we
> need to put rlimit stuff. How do we apply rlimits to the functions we need
> to and which functions do we need to ;)

Simplified, I think you could say that a thread is the series of
function-calls starting with a function that DGD itself called.

If in your code you do call_out("foo", 10), then in about 10 seconds
DGD will start a new thread beginning with the call to function foo()
in this_object(), assuming the object still exists. ;-)

Another thread-start is when DGD receives input from a network
connection and calls receive_message() in the relevant user-object.

So your typical receive_message() function would look like this:

    static void
    receive_message(string str)
    {
	rlimits (MAX_STACK; MAX_TICKS) {
	    /*
	     * Do what you would normally do, parse and execute
	     *  command-functions
	     */
	}
    }

To make sure a function started by a call_out() is wrapped inside such
an rlimits construct, you would have to redefine call_out() in your
auto-object, like this:

    static int
    call_out(string func, int delay, mixed args...)
    {
        return ::call_out("_F_call_out", delay, func, args);
    }

    nomask void
    _F_call_out(string func, mixed *args)
    {
        if (previous_program()) {
	    rlimits (MAX_STACK; MAX_TICKS) {
		call_other(this_object(), func, args...);
	    }
        }
    }

The 'if (previous_program()) {' condition is to make sure the function
cannot be abused by calling it directly, this way it will only call
the given function with the parameters if it's the start of a thread.

If you're thinking of making _F_call_out() a static function, think
again, because that would make it an 'efun' since it's in the auto-
object, and then you cannot call it from a call_out(). :-)

Of course, this means that status(obj)[O_CALLOUTS] will look slightly
differently.

Some other entry points that you may want to protect the same way
receive_message() is protected are open() and close() in user-objects,
depending on trust the executed code 100% to not do anything stupid.

Hope this helps,

Erwin.
-- 
Erwin Harte <harte@xs4all.nl>



Date: Thu Sep 13 22:12:01 2001
Subject: [DGD] Hope someone can help
In-Reply-To: <B7C724AE.15C7%mtaylor@ntlworld.com>
References: <15265.24318.832870.864535@alyx.skotos.net>
 <B7C724AE.15C7%mtaylor@ntlworld.com>
Message-ID: <15265.29962.997747.495047@alyx.skotos.net>

Matt,

Happy to be of assistance. And you really should stop apologizing
for your questions... technical savvy may be useful for precisely
the sort of thing you are trying to do, but it is really a rather
over-specialized skill which in my opinion commands far more real-
world respect than it really deserves, especially in the USA. :-)

I also think trying to write a -game- rather than a MUD operating
system (which half the people on this list have done) is a lovely
change of priorities, and I hereby cheer you on wildly.

First some specifics --

 > The thing is ... I don't know what ticks and stacks are. I know that
 > probably makes me seem like a four year old running for president ;)
 > We are not going to run the standard code/builders thing. We want to have a
 > test mud where we can fully test new code as it comes along. Code will be
 > submitted by other coders and not written from within the mud.

A tick should be considered a unit of time. If a code takes a lot
of ticks, it's taking a lot of time. If there is no restriction on
how many ticks some piece of code can take before it is violently
aborted, then there is no restriction on the amount of time it can
take. If there is no restriction on the amount of time, then that
piece of code can take forever to run. If it takes forever to run,
then nothing else can run. If nothing else runs, you don't have a
functional Mud.

Thus you want to restrict the amount of ticks (time) untrusted code
is allowed to take up. This is done with rlimits.

What stack really is is not very important nor very interesting --
just consider it another finite resource that you want to stop some
random piece of code from using up.

If you do

	rlimits(100, 100) {
		blah;
	}

then the code 'blah' is only allowed to take up 100 ticks and 100
stack before it completes. 100 tick is a silly value, 100,000 may
be more realistic. 100 stack is generous.

 > To be honest with you ... I didn't understand any of the bit about Callout
 > Gateways and the like ... Sorry Par :(

Don't be sorry. It's an extremely specialized, extremely technical
notion that you're not really supposed to have to think about to
make a game. Unfortunately you've chosen not to use the kernel lib,
which is the single piece of software generally available that will
try to do some of these tasks for you. :)

The explanation: callouts are one of the few things that can start
the execution of some code, so if you want to make sure code can't
execute with infinite limits, the very beginning of every callout
is an ideal place to put rlimits.

 > I also wondered what you mean by putting a bunch of r-limits in the 'right
 > places' ... Um ... Where would the right places be? Any advice on where to
 > put r-limits. And how do I do that?
 > Also what is it I need to do about call-outs? Is it preventing call-out's
 > being made when their aren't enough stack/tick thingies which I suppose
 > would be bad for the mud running?

Now instead of answering the specifics I'll answer generally -- you
either need to

 A) not to care about ticks and stack ... this would probably be my
    approach, though I would eventually regret it,
 B) quickly switch to using the kernel library, which is a far from
    trivial an operation, but much easier than building your own, or
 C) either finding somebody who actually -enjoys- this sort of work,
    or prepare to spend many nights staring at code that is 100% tech
    and 0% game...

My suggestion is you do A) now until you are more skilled, then
C) and then finally B)  :-)

 > Last question on that ... Does it matter if we didn't include r-limits any
 > where? Is it something that will prevent our mud from working?

It means any infinite for-loop anywhere in the game would freeze the
game until you reboot it from the last good statedump... and a bunch
of similar risks. Of course, after you rebooted, you would eventually
hunt down this buggy for-loop and fix it... and you'd be fine until
the next buggy for-loop. It's a fragile foundation on which to build
something as complex as a persistent Mud though.

 > > I suggest the only way you can make a large persistent fantasy
 > > Mud is to hook up with a developer who is willing to really dig
 > > into these complex issues -- especially if you're not doing it
 > > with the kernel library.
 > 
 > That sounds ominous :( Do you really think that we can't / shouldn't go
 > further without another developer helping out with these things. Our code
 > and ideas are great ... Haven't seen lots of them in any other muds about.
 > I've introduced ideas from the rl rpg system me and friends have developed
 > over 6 - 7 years. And I'm proud at least that we have got this far ;)

DGD is by design a minimalist driver, which means that there is need
for a chunk of LPC code between DGD itself and the 'game' which is
very technical. If you don't want to write this code yourself, you
need something like the kernel library. Even if you do have the kernel
library, you need somebody to understand it and to interface the rest
of the game with it...

Zell



Date: Thu Sep 13 22:13:01 2001
Subject: [DGD] Hope someone can help
In-Reply-To: <B7C724AE.15C7%mtaylor@ntlworld.com>; from mtaylor@ntlworld.com on Fri, Sep 14, 2001 at 03:06:22AM +0100
References: <15265.24318.832870.864535@alyx.skotos.net> <B7C724AE.15C7%mtaylor@ntlworld.com>
Message-ID: <20010914051031.D31947@mail.is-here.com>

On Fri, Sep 14, 2001 at 03:06:22AM +0100, mtaylor wrote:
[...]
> > 
> > To be honest, since you have full control of all the code, you can
> > probably just stick a bunch of rlimits in the right places and do
> > something about callouts.
> 
> The thing is ... I don't know what ticks and stacks are. I know that
> probably makes me seem like a four year old running for president ;)
> We are not going to run the standard code/builders thing. We want to have a
> test mud where we can fully test new code as it comes along. Code will be
> submitted by other coders and not written from within the mud.

The 'stacks' refers to one function calling another, which calls
another, etc.  If your 'stack' of functions calling eachother gets too
deep for the current rlimits settings, DGD will abort it.  This will
not be a problem unless you're doing some interesting recursive
functions, be they intentional or not.

The 'ticks' refer to the fact that everything you do in LPC will be
assigned with a 'cost in #ticks', with a minimum cost of 1, more
complicated operations such as certain array or mapping operations
would cost more depending on the size of array/mapping they're working
with, etc.

This way, if some code ends up going in circles without getting
anywhere, DGD can at some point say "All good and fun, but you've used
up all the ticks you've been given, now let someone else play". ;-)

> To be honest with you ... I didn't understand any of the bit about Callout
> Gateways and the like ... Sorry Par :(

I think he is referring to what I describe a few paragraphs further in
my reply here.  What, you reply to messages by beginning at the top?!

> I also wondered what you mean by putting a bunch of r-limits in the 'right
> places' ... Um ... Where would the right places be? Any advice on where to
> put r-limits. And how do I do that?

The right places would be 'anywhere that you could start a new thread'
in other words anywhere that DGD calls functions into objects.

Examples:
- receive_message()
- open() & close()
- the functions called from a call_out().

> Also what is it I need to do about call-outs? Is it preventing call-out's
> being made when their aren't enough stack/tick thingies which I suppose
> would be bad for the mud running?

You want to overrule the original call_out() kfun and replace it by
one that calls a helper function that calls the _intended_ function
inside a 'rlimits (..; ..) { .. }' block.

> Last question on that ... Does it matter if we didn't include r-limits any
> where? Is it something that will prevent our mud from working?

It could, if someone got it into their head to write a piece of code
that effectively did this:

  while (1) {
     ...
  }

because, with no ticks-restrictions, it would never be aborted by DGD,
so nothing else could happen anymore!

Heop this helps,

Erwin.
-- 
Erwin Harte <harte@xs4all.nl>


From dgd at list.imaginary.com  Mon Nov  5 08:10:01 2001
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Mon Nov  5 08:10:01 2001
Subject: [DGD] Diferences... Thank you, and more cuestions.
Message-ID: <200111051400.PAA05757@dworkin.nl>

Arnau Rosselló Castelló wrote:

> Another question: What Is a tick exactly? It measures CPU capacity,
> but is it a fixed time length? a variable time length that depends on
> the power of the processor? it works with time at all or measures the
> number of instructions?

A weighted measure of the number of instructions and the size of the
datastructures manipulated by these instructions.


> YAQuestion: Is there any way to know the maximum and/or actual
> ticks and stack? I'm thinking on making that compile_object() and
> clone_object() assign a certain cuantity of ticks and stack to the com-
> piled/cloned object, who will be called everytime with that amount of
> stack/ticks, and substracting that many ticks and stack from the assigned
> to the object calling compile/clone. Do you think this is viable, or
> is my idea flawed in some way?

You can set the ticks and stack depth available to code with rlimits,
and query current values with the status() kfun.  Limiting the amount
of resources available to objects is a good idea.  In fact, the kernel
library does exactly that. :-)

Regards,
Dworkin


From dgd at list.imaginary.com  Sun May 25 17:06:01 2003
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Sun May 25 17:06:01 2003
Subject: [DGD] Rlimits weirdness...
In-Reply-To: <20030525215750.30614.qmail@web12808.mail.yahoo.com>
Message-ID: <200305252205.h4PM5WgI017213@pattern.dworkin.nl>

Noah Gibbs <noah_gibbs@yahoo.com> wrote:

>   I'm seeing some odd behavior, and the Kernel Library
> definition of runtime_rlimits() in the Driver seems to
> be the cause.
>
>   An object in /usr/System is permitted to set
> maxticks to -1, which will remove all limits on ticks.
>  On the other hand, the same object isn't allowed to
> (for instance) set the limit to 250,000 repeatedly so
> that it can run many consecutive time-limited
> operations in the same thread.  Is this for security
> reasons and I'm just not getting it?

What you can't do is set a tick limit and then raise it.  Non-negative
tick limits can only be set when the current limit is -1 (infinite).
Once a limit is set, you are committed.  You can voluntarily lower it,
though.

>From your description, I think you should be setting the limit to
250,000 from where the current limit is infinite.  That'll allow you
to run the consecutive time-limited operations, as you describe.

Regards,
Dworkin



From dgd at list.imaginary.com  Sun May 25 17:59:00 2003
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Sun May 25 17:59:00 2003
Subject: [DGD] Rlimits weirdness...
In-Reply-To: <20030525223325.34312.qmail@web12808.mail.yahoo.com>
Message-ID: <200305252258.h4PMw4Zq017357@pattern.dworkin.nl>

Noah Gibbs <noah_gibbs@yahoo.com> wrote:

> --- "Felix A. Croes" <felix@dworkin.nl> wrote:
> > What you can't do is set a tick limit and then raise
> > it.  Non-negative
> > tick limits can only be set when the current limit
> > is -1 (infinite).
>
>   Hm.  So since call_out sets a non-negative tick
> limit, that means I can only lower it.  So I guess
> I'll need to make every upgraded() call its own
> call_out.  I was trying to avoid that.

You don't have to, as long as you go back to unlimited ticks first:

    rlimits (-1; 0) {
	rlimits (250000; 0) {
	    task1();
	}
	rlimits (250000; 0) {
	    task2();
	}
	/* ... */
    }

Or, even better:

    rlimits (-1; 0) {
	call_limited("task1");
	call_limited("task2");
	/* ... */
    }

Regards,
Dworkin

From dgd at list.imaginary.com  Sun May 25 18:23:00 2003
From: dgd at list.imaginary.com (Felix A. Croes)
Date: Sun May 25 18:23:00 2003
Subject: [DGD] Rlimits weirdness...
In-Reply-To: <20030525231052.77775.qmail@web12804.mail.yahoo.com>
Message-ID: <200305252322.h4PNM1HA017463@pattern.dworkin.nl>

Noah Gibbs <noah_gibbs@yahoo.com> wrote:

>   I wanted to use call_limited, but it's static.  And
> rather than making every upgraded() call in every
> object use it manually (definite security hole, and
> inconvenient), I'd have to do the same thing from
> ObjectD, which can't get at some of the information it
> would need to do that.

Static functions can be called with call_limited().  Beyond that,
it is not clear to me exactly what you are trying to do, so it is
hard to offer advice.


>   So for the moment I just have two rlimits calls
> surrounding the call_other.  It looks silly, but it
> works.
>
>   I still find it very odd that the Kernel Library
> allows that, but disallows it with only one call.

It disallows raising the ticks limit, unless you are in "supervisor"
mode, i.e. running with no ticks limit.  Note that you cannot deal
with running out of ticks unless you do the dealing in code that has
no ticks limit (unless you make the whole operation atomic).

System objects are subject to the same restrictions on raising ticks
as other objects, to avoid accidents where the ticks limit is raised
forever in an infinite loop.

Regards,
Dworkin
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
            <address>
            <span><a href="mailto:angelbob-remove-spamfree@spamfree.users.sf.net">Noah Gibbs</a></span>
            </address></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
