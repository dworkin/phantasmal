  <titledef text="Swapping" />

  <h2> DGD's Swapping Behavior </h2>

  <p>
    DGD calls itself a &quot;disk-based&quot; server.  That means that
    DGD will swap out objects after they've been unused for awhile.
    It uses a standard LRU (Least Recently Used) metric to determine
    which objects should be removed from memory.  This swapping is
    entirely transparent from the point of view of the LPC code.  All
    LPC code executes as though every object was in RAM at all times,
    and objects will be pulled into memory as they are referenced.
  </p>

  <p>
    DGD's configuration file contains a parameter called
    swap_fragment.  That's the fraction of all objects that should be
    removed from memory.  For instance, if swap_fragment is equal to
    20, then one-twentieth of all objects will be swapped out at the
    end of every thread of execution.  A smaller swap_fragment will
    cause DGD to use less memory, but will also mean more disk access
    is necessary as objects are written.
  </p>

  <p>
    Objects are stored as sectors.  The sector_size parameter tells
    how large a single sector is, in bytes.  Every object takes up a
    multiple of the sector size in the swap file.  So if the sector
    size were 1024, no object could take less than one kilobyte to
    store in the swap file.  An object with 3217 bytes of data would
    wind up actually taking 4096 bytes in the swap file, or four
    sectors.  A small sector size can save some space that way, though
    a very small sector size (like, say, 64 bytes) will require the
    DGD server to use up a lot of processor time and memory in
    managing so many sectors.
  </p>

  <p>
    The swap_cache config parameter says how many sectors can be in
    RAM at once.  If this is large, DGD runs fast.  If it's small, DGD
    takes less memory.
  </p>

  <p>
    An object is swapped back into memory when one of its functions is
    called, or when certain driver functions are called on it.
  </p>

  <p>
    When an object is swapped out, it will only be written out if it
    changes.  Having large objects that change frequently can make for
    much slower swapping.  Consider separating the highly-changeable
    parts of the objects into smaller DGD objects that will swap
    separately.
  </p>

  <h3> Disabling Swapping </h3>

  <p>
    If you experience very high usage by your MUD of your machine's
    CPU, but DGD's usage of ticks doesn't account for it, then DGD's
    housekeeping tasks, especially swapping, may account for the
    difference.  If your MUD can fit entirely in RAM, you can find out
    if swapping is your problem by temporarily turning off swapping
    and only using RAM.
  </p>

  <p>
    In your DGD configuration file, set swap_fragment to 0.  That will
    turn off ordinary swapping, but not certain operations where all
    objects are swapped out to make room for larger contiguous blocks
    of static memory.  By setting static_chunk to 0 as well, you can
    eliminate all swapping in your application, even those operations.
  </p>

  <p>
    Remember to turn swapping back on afterward!
  </p>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
