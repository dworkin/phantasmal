  <titledef text="Swapping" />

  <h2> DGD's Swapping Behavior </h2>

  <p>
    DGD calls itself a &quot;disk-based&quot; server.  That means that
    DGD will swap out objects after they've been unused for awhile.
    It uses a standard LRU (Least Recently Used) metric to determine
    which objects should be removed from memory.  This swapping is
    entirely transparent from the point of view of the LPC code.  All
    LPC code executes as though every object was in RAM at all times,
    and objects will be pulled into memory as they are referenced.
  </p>

  <p>
    DGD's configuration file contains a parameter called
    swap_fragment.  That's the fraction of all objects that should be
    removed from memory.  For instance, if swap_fragment is equal to
    20, then one-twentieth of all objects will be swapped out at the
    end of every thread of execution.  A smaller swap_fragment will
    cause DGD to use less memory, but will also mean more disk access
    is necessary as objects are written.
  </p>

  <p>
    Objects are stored as sectors.  The sector_size parameter tells
    how large a single sector is, in bytes.  Every object takes up a
    multiple of the sector size in the swap file.  So if the sector
    size were 1024, no object could take less than one kilobyte to
    store in the swap file.  An object with 3217 bytes of data would
    wind up actually taking 4096 bytes in the swap file, or four
    sectors.  A small sector size can save some space that way, though
    a very small sector size (like, say, 64 bytes) will require the
    DGD server to use up a lot of processor time and memory in
    managing so many sectors.
  </p>

  <p>
    The swap_cache config parameter says how many sectors can be in
    RAM at once.  If this is large, DGD runs fast.  If it's small, DGD
    takes less memory.
  </p>

  <p>
    An object is swapped back into memory when one of its functions is
    called, or when certain driver functions are called on it.
  </p>

  <p>
    When an object is swapped out, it will only be written out if it
    changes.  Having large objects that change frequently can make for
    much slower swapping.  Consider separating the highly-changeable
    parts of the objects into smaller DGD objects that will swap
    separately.
  </p>

  <h3> Disabling Swapping </h3>

  <p>
    If you experience very high usage by your MUD of your machine's
    CPU, but DGD's usage of ticks doesn't account for it, then DGD's
    housekeeping tasks, especially swapping, may account for the
    difference.  If your MUD can fit entirely in RAM, you can find out
    if swapping is your problem by temporarily turning off swapping
    and only using RAM.
  </p>

  <p>
    In your DGD configuration file, set swap_fragment to 0.  That will
    turn off ordinary swapping, but not certain operations where all
    objects are swapped out to make room for larger contiguous blocks
    of static memory.  By setting static_chunk to 0 as well, you can
    eliminate all swapping in your application, even those operations.
  </p>

  <p>
    Remember to turn swapping back on afterward!
  </p>

  <h3> Transparency </h3>

  <p>
    All of this nifty swapping stuff Just Happens(tm).  That is, you
    should never, as a programmer, specifically need to request it.
    Objects are swapped out at the end of threads according to the
    swap_fragment configuration parameter, and they're swapped in when
    you use them.  It should never be necessary to explicitly request
    a swap-in for an object.
  </p>

  <p>
    If you ever wish to explicitly request a swap-out, there's a kfun
    called swapout() which will swap <i>every</i> object out.
  </p>

<pre>
From: DGD Mailing List (Felix A. Croes)
Date: Tue Jan 14 06:38:01 2003
Subject: [DGD] Object swap-in

Birgit Schulte wrote:

> While overhauling my object-daemon, I stumbled upon a basic question:
>
> When exactly does an object which is swapped out get swapped in again?
> Does it happen if I do a find_object(obj) or status(obj)?
>
> Or only if the object is either compiled or a function called within it?

find_object() does not swap in an object; status() does, because some of
the information needed by that function is swapped out.  However,
status() only swaps in the first sector of an object's dataspace.
Calling a function in an object would cause much more of the object
to be loaded in memory.

If you want to avoid any disk access, you may want to cache some of the
information from status(obj) in your object daemon.

Regards,
Dworkin
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
