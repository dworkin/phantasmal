  <titledef text="Object Database" />

  <h2> Using an Object Database </h2>

  <p>
    A question that appears frequently on the MUD-Dev list and
    occasionally on the DGD list is whether it would be a good idea to
    use an external database to store MUD objects and have DGD access
    that database rather than storing the objects itself.
  </p>

  <p>
    Using a standard database (say MySQL or PostgreSQL) has some
    significant problems.  There's a reason that DGD doesn't normally
    do callout to other languages &mdash; DGD has features like
    rlimits() and atomic functions that are very difficult to
    implement cross-language.  To use an external database, you'd need
    to create a module for DGD to handle these constructs and handle
    interruptions gracefully.  That's not impossible, but it's quite
    difficult.  You could declare that rlimits() and atomic functions
    don't work correctly for database operations.  But you'll find
    that storing all your MUD's objects in a database will thus make
    those features entirely useless.
  </p>

  <p>
    Similarly, DGD's other large, unique feature &mdash;
    upgrade-in-place &mdash; will present difficulties.  Any change in
    the object's data fields will need to update the database fields
    as well, which will be a significant undertaking.  It's quite
    possible to do so, but it's another reason that DGD is simply a
    poor fit for the idea of storing objects in an external database.
    The fact that DGD already stores them so well and so quickly means
    that the possible benefit of using an external database is much
    smaller as well.  In general, DGD is simply poorly suited to the
    use of an external database.
  </p>

  <p>
    Dworkin has mentioned the possibility of eventually modifying DGD
    to be able to use an external object database.  However, he's not
    planning to do it at <i>least</i> until multiprocessor support is
    done.  When&frasl;if that occurs, the 'poor fit' comments above
    will presumably be obsolete.
  </p>

  <h3> Internal Databases </h3>

  <p>
    Well, what about a database written in LPC?  You could have an
    object that redirects all calls to get descriptions or other
    textual data to a large database daemon.  Would this cut down on
    memory and increase on processor use?
  </p>

  <p>
    Hard to answer.  Some considerations:
  </p>

  <p>
    Strings are shared within objects.  Constructed strings (such as
    the results of string addition or taking a substring) are not
    shared with identical strings created in a different manner until
    the object is swapped out.
  </p>

  <p>
    putting many shared strings in a single object creates a huge
    object that would have to be in memory all the time, quite
    possibly &lt;increasing&gt; memory use though decreasing swap file
    size.
  </p>

  <h3> Socket Interfaces to Databases </h3>

  <p>
    You can get around these problems by not calling directly to the
    database, but instead accessing it over a socket interface.  This
    is possible, but is essentially using the database as an external
    server, one on which no actual LPC objects are stored.  This is
    useful, for instance, if web pages are there and DGD will be
    looking at them and maybe processing or serving them, but will not
    be upgrading them directly or otherwise modifying them as LPC
    objects.  In that case, the database can be accessed like any
    other external server.  Doing so may require the network patch if
    outgoing connections must be made from the DGD server.
  </p>

<pre>
From: DGD Mailing List (Noah Gibbs)
Date: Wed Nov 20 10:01:01 2002
Subject: Speculative Execution -- WAS:[DGD] Using MySQL C++ API

On Wed, 20 Nov 2002, Erwin Harte wrote:
> It's only right out with MySQL if you use auto-commit features or use
> tables that lack a rollback feature, I would think?

  Correct, assuming there are no side-effects and you can break out
interruptibly on command.  However, you can't just use the existing C++
API unless you integrate it pretty closely into DGD -- just doing callout
won't work.  Even if MySQL can support those features, they have to be
integrated very carefully and very specifically in a way that currently
requires putting them into a new, modified DGD server.

  Conceivably, DGD could allow a callout interface where DGD code can call
into other code, and the other code would just have to supply all kinds of
hooks for interruptability and atomicity.  In practice, so few other
pieces of code of any kind allow this that there's no reason for it --
it's less work to just integrate MySQL into DGD once (and possibly add
more layers of rollback, which you'd have to either way) than to build a
general interface like this and then only use it for MySQL.  I can't think
of very many other pieces of code you can do those things with, and
adding them pretty much eliminates the other code's speed advantage over
DGD.  Plus you've gotta deal with things like tick counts for non-DGD
code.  It all gets to be a mess.

  Granted, it'd be cool to be able to write in Perl and do the atomicity,
interruptability and CPU usage stuff.  But then why get DGD involved?

> I would describe speculative executation as "Let's start executing
> this thread, keeping track of the changes we've made so far, and just
> see where we run into trouble".  Trouble is defined as two threads
> modifying the same thing, since only one should be able to succeed in
> doing so.  If this happens, the one detecting the conflict will be
> rolled back and reattempted from the start.
> 
> At least, I hope I described that accurately. :)

  That's my understanding.  In case I haven't said before:  I think that's
a *really* cool approach to multithreading!

- Noah Gibbs
</pre>

  <p style="text-size: 150%"> <a href="../index.html"> Back to top level
    </a> </p>
