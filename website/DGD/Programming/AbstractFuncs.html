<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DGD and LPC: DGD/MP and Threads</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../../phantasmal.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="95%" border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td colspan="2"> <table width="100%" border="0" cellspacing="1"
        cellpadding="0" class="main">
        <tr>
          <td class="banner">The DGD Driver</td>
        </tr>
      </table></td>
  </tr>
  <tr>
    <td valign="top">
      <table width="25%"  border="0" cellspacing="1"
             cellpadding="0"  class="main">
        <tr>
          <td class="content" style="font-size: 120%">

          <ul style="margin: 0; padding-left: 10%">
            <li> <a href="../index.html">DGD &amp; LPC Page</a> </li>
	    <li> <a href="../LPC">LPC Textbook</a> </li>
	    <li> <a href="../Book/html/">New LPC Introduction</a> </li>
          </ul>

        </td>
        </tr>
        <tr>
          <td class="content" align="center">
            <a href="http://validator.w3.org/check/referer">
            <img src="../../images/valid-xhtml10.gif" alt="Valid XHTML 1.0!"
             style="border:0;width:88px;height:31px" /></a><br />
            <img src="../../images/pixel.gif"
             style="border:0;width:88px;height:1px" alt="" /><br />
            <a href="http://jigsaw.w3.org/css-validator/check/referer">
            <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!" style="border:0;width:88px;height:31px" />
            </a><br /><br /><br />
            <a href="http://sourceforge.net">
            <img src="http://sourceforge.net/sflogo.php?group_id=48659&amp;type=2"
             style="border: 0; width: 125; height: 37;"
	     alt="SourceForge.net Logo" /></a>
          </td>
        </tr>
      </table></td>
    <td> <table width="100%"  border="0" cellspacing="1" cellpadding="0" 
          class="main">
        <tr>
          <td class="heading">&nbsp;&nbsp;&middot;&nbsp;
	    <a href="http://phantasmal.sf.net/DGD">DGD Page</a> &gt;
            <a href="">DGD/MP and Threads</a>
          </td>
        </tr>
        <tr>
          <td class="content">
  

  <h2> DGD/MP and Multiple Threads </h2>

<pre>
From: dgd@dworkin.nl (Felix A. Croes)
Date: Thu Apr  7 02:02:01 2005
Subject: [DGD] 1.2.102

>  - Forbid having undefined private functions.
>  - Add a list of undefined functions to status(obj).

To clarify: you can have a prototype for a private function, but if so
it must be declared for the same program.  So just

    private void foo();

is wrong, but

    private void foo();

    private void foo()
    {
	/* do the foo thing */
    }

is no problem.

The list of undefined functions is added so that a mudlib can forbid
active use of such objects, and can generate reasonable errormessages.
>From a Java point of view, an object with only prototypes would be an
interface.

The "list" is actually a mapping.  When object obj has no undefined
functions, status(obj)[O_UNDEFINED] is nil.  Otherwise, it is a
mapping of the following format:

    ([ program_name : ({ func1, func2, ... )}, ... ])

Regards,
Dworkin
</pre>

<hr />

<pre>
From: dgd@dworkin.nl (Par Winzell)
Date: Thu Apr  7 21:24:01 2005
Subject: [DGD] 1.2.102

Felix A. Croes wrote:

> The list of undefined functions is added so that a mudlib can forbid
> active use of such objects, and can generate reasonable errormessages.
> From a Java point of view, an object with only prototypes would be an
> interface.
> 
> The "list" is actually a mapping.  When object obj has no undefined
> functions, status(obj)[O_UNDEFINED] is nil.  Otherwise, it is a
> mapping of the following format:
> 
>     ([ program_name : ({ func1, func2, ... )}, ... ])

The mudlib support to provide 'proper' support for abstract functions is
not entirely trivial, and as I just finished (with Dworkin helping me
work through the issues) an implementation for the SkotOS 2.0 codebase,
I thought I'd briefly summarize my findings. This is probably only one
of many possible implementations, especially since I assume the use of
the kernel library.

 - You will want to mask compile_object() in the System level auto
object, if you are not already doing so. You need two separate systems
to check for two separate kinds of unimplemented functions:
    + For concrete objects, use status(obj)[O_DEFINED] and simply report
any unimplemented functions that are either declared in the compiled
program or inherited normally. A concrete object by definition should
not have any undefined functions.
    + The status() function does not report prototypes that were
privately inherited. It is quite common to privately inherit a program
that declares prototypes it expects its inheritor to implement. To catch
cases where the inheritor fails to implement them:
      * Allocate space for a new TLS slot.
      * In your objectd, add code to forbid_inherit(), compile() and
compile_lib() that keeps track of the undefined functions of each
privately inherited program.
      * In your masked compile_object(), initialize the TLS slot with
whatever data you need for the previous step. Remember that compilation
of one program may trigger compilation of many other programs when
creators are run.
      * At the end of compile_object(), go through the datastructure
(which is likely quite large) you collected in the objectd. For each
compiled program:
        $ Figure the master list of privately inherited undefined functions.
        $ From this master list, REMOVE any undefined functions that
were NON-privately inherited. If I inherit a prototype both privately
and non-privately, the private inheritance is irrelevant.
        $ From the rest of the master list, REMOVE any function that is
actually defined by the compiled program. To do this, you will need to
employ function_object(), but:
          = function_object() from the 'outside' fails to detect static
methods and so you need to create some kind of function_exists() relay
in the auto object that performs function_object() on itself
          = function_object() cannot be run on pure programs, because
the kernel library forbids us from getting an object pointer to such a
program; thus we create a temporary object that does very little but
inherit the program we actually want to test, and then call
function_exists() on this program.


Phew. OK, that sounded complicated. I guess it was. But it works! LPC
has matured even further!

Zell
</pre>

  <p style="text-size: 150%"> <a href="index.html"> Back to DGD &amp; LPC
      Page </a> </p>
            <address>
            <span><a href="mailto:angelbob-remove-spamfree@spamfree.users.sf.net">Noah Gibbs</a></span>
            </address></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
