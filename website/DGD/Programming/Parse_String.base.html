  <titledef text="Using parse_string" />

  <h2> Using DGD's parse_string Kfun </h2>

  <p>
    The parse_string kfun is a very powerful parser to which you
    supply a grammar of your choice.  It's much like lex and yacc, and
    defines its own mini-language within DGD, much as lex and yacc do
    with C.  DGD's parse_string, unlike most parsers, keeps track of
    all your ambiguous matches.  That fact is both a great power and a
    great responsibility.
  </p>

  <p>
    What that means is that if your grammar allows something to be
    parsed a couple of different ways then DGD will keep track of them
    all while parsing.  If there are two ways to parse a double-if
    statement with else (the else can go with either if) in your
    grammar, and you feed parse_string a chunk with fifteen of those,
    you'll find that DGD is keeping track of 2^15 (that's a little
    more than 32,500) different interpretations of your file. Then it
    will cheerfully return only the first.  That's slow, just in case
    you hadn't guessed.
  </p>

  <p>
    Similarly, if your grammar contains a rule like <tt>element_list:
    element_list ',' element_list</tt> and also a rule to have
    <tt>element_list</tt> match, say, an integer, then the input
    &quot;17,25,3,17534,37,3524,2,1,359&quot; will also have many
    possible parse trees, and will also take a very long time to
    complete.  In a library like the Kernel Library that tries to
    prevent infinite loops, you'll usually find you're out of ticks
    and one of your rlimits() statements interrupts you midway through
    the parsing.
  </p>

  <p>
    However, sometimes you <i>want</i> ambiguous parsing.  For
    instance, you may have a natural language parser for player
    commands, and you'd like the player to be able to type &quot;get
    down&quot; and have it mean either of &quot;get down from the
    platform&quot; or &quot;take the down pillow&quot; according to
    two different grammar rules.  DGD's parse_string will return both
    parses, and you can decide which makes more sense for the player
    currently.  Most parsers won't find all ambiguous matches for a
    given grammar and input.
  </p>

  <p>
    A fellow on the list named Steve Foley has graciously put together
    a tutorial on parse_string, with the aid of Erwin Harte.  You can
    find it <a href="../external/parse_string.html">here</a>.
  </p>

  <hr />

  <ul>
    <li> <a href="../external/lpc_grammar.txt">An (outdated) grammar
        for DGD's LPC dialect</a></li>
    <li> <a href="../external/ps_example_1.txt">Dworkin's example of
        using functions to affect the final parse tree</a> </li>
    <li> <a href="../external/ps_example_2.txt">Efficiency of sscanf
        versus parse_string</a> </li>

    <li> <a href="../external/ps_example_3.txt">A more specific
	discussion about efficiency of sscanf versus parse_string</a>
    </li>

    <li> <a href="../external/ps_example_4.txt">Dworkin
	discussing simple left-recursive rules for lists</a>
    </li>

  </ul>

  <hr />

  <h3> More Messages About Using parse_string() </h3>

<pre>
Date: Fri, 28 Jan 2000 14:34:04 +0100 (CET)
From: "Felix A. Croes" <felix@dworkin.nl>
Message-Id: <200001281334.OAA03750@pattern.dworkin.nl>
To: dgd@list.imaginary.com
Subject: Re: [DGD]parse_string

Ludger Merkens <balduin@uni-paderborn.de> wrote:

>[...]
>     grammar = "                     \
> whitespace=/[ \t\n\r\v\f]+/         \ /* strip some chars */
> whitespace=/[!-\\[\\]|]+/           \ /* some more        */
> tag=/<[^<]*>/                       \ /* tags start with <, end with >
> term =/[a-zA-Z]+'s/                 \ /* e.g. GNU's */
> term =/\\(*[a-zA-Z`']+\\)*/         \ /* Hello or 'Hello' */
> eol =/<[^<>]*/                      \ /* < but neither < nor > follows. */
> s : tag s                           \
> s : term s                          \
> s : term                            \
> s : eol                             \ /* broken tag at end of chunk */
> s : tag                             \
> ";
>
> First of all, I want to know how the whitespace rules are used, e.g. I 
> stumbled over a tag containing \n in spite of the first whitespace rule.

Whitespace is matched like any other token: take the longest possible
match.  The longest possible match for "tag" explicitly allows embedded
whitespace, as does the longest possible match for "eol".  Also note
that the rule for tag matches "<foo>>>>>".


> Second I need some details about efficiency of parsing. If I use this
> grammar on a string containing html with length of 1000 chars, I have
> a cost of about 25240 ticks. Whereas I get for 2000 chars 181664 ticks
> and for 3000 even 591632. 

This is becaus the grammar is right-recursive for s.  If you replace
the first two rules with left-recursive rules, the grammar will become
more efficient:

    s: s tag
    s: s term


> - Which execution costs do I have to expect O(n^2), O(n^3) ... (be n the
>   length of the string)

Parsing with the (suitably rewritten) grammar above would have cost
O(n).  The worst case for a LR grammar is O(n^3).  The worse case for
an ambiguous grammar is O(n^m), where m is the number of rules in the
grammar.


> - In how far is the cost dependend on the grammar, are there rules which
>   are parsed faster than others? Are there some good books, url's how to
>   build a well formed (fast parsed) grammar (kfg)

SLR grammars are handled most efficiently, especially if they have no
recursion or only left recursion.  Next are LALR, LR, non-ambiguous, and
ambiguous, in that order with the most efficient worst case first.

You can read up on grammars in books about compiler construction, the
Chomsky language hierarchy, or even in Linux documentation for flex and
yacc.  A good book about compiler construction is

    Aho, Sethi, Ullman: Compilers -- Principles, Techniques, and Tools
    Addison Wesley 1986, second edition

Regards,
Dworkin
</pre>

<hr />

<pre>
Date: Tue, 1 Feb 2000 15:10:10 +0100 (CET)
From: "Felix A. Croes" <felix@dworkin.nl>
Message-Id: <200002011410.PAA11957@pattern.dworkin.nl>
To: dgd@list.imaginary.com
Subject: Re: [DGD]parse_string

Ludger Merkens <balduin@uni-paderborn.de> wrote:

> Another parse_string example
> I try the following:
>
>     grammar = "\
> whitespace=/[ !-[]+/            \ /* note the [ in the set */
> tag=/<[a-zA-Z]+>/               \
> term =/\\(*[A-Za-z`']+\\)*/     \
> s : term ? _term                \
> s : tag ?  _tag                 \
> ";
>
> if i call parse_string("! <abc>",grammar) i receive
> ({"abc"}) and the function _term is called.
> looks wrong to me.

Token rules, from dgd/doc/parser:

    [set]   a single character in the given set, which is constructed of
            single characters such as `a' and/or character ranges such as
            `a-z'.  `\' may be used to escape the characters `]', `^', `-', `\'

The range `!-[' is perhaps more inclusive than you suspected.

The alternative grammar succeeds because `-' at the beginning or end
of a character set obviously cannot be part of a range, and therefore
is not interpreted as such.

Regards,
Dworkin
</pre>

  <p style="text-size: 150%"> <a href="index.html"> Back to DGD &amp; LPC
      Page </a> </p>
