@@TITLE What Does It Do?@@

<h1>What, Exactly, Does DGD Do?</h1>

<p>Different programming languages have different runtime models. Most
languages have a stack, for instance, where functions' copies of local
variables get stored. Some languages have garbage collection, automatic
locking or other features that operate at different times. DGD has its
own set of interesting features that do interesting things at
interesting times.</p>

<h2>When Does DGD Code Execute?</h2>

<p>DGD retains more control over its execution model than most
languages. Almost all code written in DGD is meant to run very briefly
in response to an event of some kind, and then exit. When code is run in
response to an event and then completes, it is called a single
'Execution Round'. You may also see it called a 'thread' or 'DGD
thread', though this is <i>not</i> similar to the way threading works in
other languages.</p>

<p>An Execution Round may be triggered by any of the following
events:</p>

<ul>
  <li>A new network connection</li>

  <li>Input on an existing network connection</li>

  <li>A programmatically scheduled event, called a call_out</li>
</ul>

<h3>The End of the Execution Round</h3>

<p>When an execution round completes, DGD does a number of things. If
any objects are to be recompiled or destructed, that happens after the
execution round that requested the change is complete, but before the
next round starts. If the server is going to shut down, reboot, or make
a statedump file, that will also happen at that time. A lot of <a href=
"Swapping.html">memory management</a> happens at the end of the
execution round as well.</p>

<ul>
  <li><a href="Swapping.html">Swapping</a></li>

  <li><a href="StateDumps.html">StateDumps</a></li>

  <li><a href="LWOCache.html">LWOs and Swapping</a></li>
</ul>
