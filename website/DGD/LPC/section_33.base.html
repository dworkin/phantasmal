<h3><a name="SEC3.2.10" href="index.html#SEC3.2.10" id=
"SEC3.2.10">Conditionals</a></h3>

<p>Conditional statements are used a lot in LPC, and there are
several ways of writing them. A very important concept is that
<code>0</code> and <code>nil</code> are considered as <b>false</b>
and any other value as <b>true</b> in tests. This means that empty
listings <code>({})</code>, empty strings <code>""</code> and empty
mappings <code>([])</code> also are evaluated as <b>true</b> since
they aren't <code>0</code> or <code>nil</code>. You have to use
special functions to compute their size or determine content if you
want test them.</p>

<h4><a name="SEC3.2.10.1" href="index.html#SEC3.2.10.1" id=
"SEC3.2.10.1">The if and else statements</a></h4>

<p><a name="IDX38" id="IDX38"></a> The most common conditional
statement is the <code>if</code> statement. It's easy to use and
can be combined with an <code>else</code> clause to do two
different things based on a variable's value. It's written like
this:</p>
<pre>
if (expression) statement;
e.g.
    if (a == 5)
        a -= 4;
    
</pre>

<p>If you want to handle the false case, you can add an
<code>else</code> statement like this:</p>
<pre>
if (expression) true-statement else false-statement;
e.g.
    if (a == 5)
        a -= 4;
    else
        a += 18;

or

    if(a &gt; 10)
      a -= 10;
    else {
      a += 100;
      b--;
      a -= 10;
    }
    
</pre>

<h4><a name="SEC3.2.10.2" href="index.html#SEC3.2.10.2" id=
"SEC3.2.10.2">The switch statement</a></h4>

<p><a name="IDX39" id="IDX39"></a> <a name="IDX40" id="IDX40"></a>
If one variable has to be tested for a lot of different values, the
resulting list of <tt>`if-else-if-else'</tt> statements soon gets
very long and hard to read. However, if the type of the value you
are testing is an integer, a float or a string you can use a much
denser and neater way of coding. Assume you have the following code
you want to write:</p>
<pre>
if (name == "fatty")
{
    nat = "se";
    desc = "blimp";
}
else if (name == "plugh")
{
    nat = "no";
    desc = "warlock";
}
else if (name == "olorin")
{
    nat = "de";
    desc = "bloodshot";
}
else
{
    nat = "x";
    desc = "unknown";
}
    
</pre>

<p>A better way of writing this is:</p>
<pre>
switch (name)
{
case "fatty":
    nat = "se";
    desc = "blimp";
    break;

case "plugh":
    nat = "no";
    desc = "warlock";
    break;

case "olorin":
    nat = "de";
    desc = "bloodshot";
    break;

default:
    nat = "x";
    desc = "unknown";
}
    
</pre>

<p>The workings of this statement is simple: <code>switch</code>
sets up the expression value within the parenthesis for matching.
Then every expression following a <code>case</code> is compared to
find a match.</p>

<p>Note that the <code>case</code> expression <b>must</b> be a
constant value. It can't be a variable, function call or other
expression.</p>

<p>After a match has been found the following statements are
executed until a <code>break</code> statement is found. If no
matching value can be found, the <code>default</code> statements
are executed instead.</p>

<p>While it's not mandatory to have a <code>default</code> section,
it's highly recommended since that usually means that something has
happened that wasn't predicted when writing the program. It's
usually very good to have an error message to notify the user (or
you) that something unexpected happened.</p>

<p>If you forget to put in a 'break' statement the following 'case'
expression will be executed. This might sound like something you
don't want, but if in the example above the names <tt>`fatty'</tt>
and <tt>`plugh'</tt> both should generate the same result you could
write:</p>
<pre>
case "fatty":
    /* FALLTHROUGH */
case "plugh":
    &lt; code &gt;
    break;
</pre>

<p>... and save a bit of space. Writing code with switch doesn't
make it any quicker to execute. It <i>does</i> make it a lot easier
to read, which reduces the chance of making mistakes while coding.
Remember to put the <code>/* FALLTHROUGH */</code> comment there
though, or it might be hard to remember later if it was intentional
or an omission of a <code>break</code> statement. If you have code
that's executed before falling through to the next case, this is
especially important. A good idea is usually to add an extra
linefeed after a <code>break</code> statement just to give some
extra 'breathing space' to improve on legibility.</p>

<h4><a name="SEC3.2.10.3" href="index.html#SEC3.2.10.3" id=
"SEC3.2.10.3">The ?: expression</a></h4>

<p><a name="IDX41" id="IDX41"></a> This is a very condensed way of
writing an <code>if/else</code> statement and return a value
depending on how the test turned out. The <code>?:</code> operator
isn't a statement, it's an expression since it returns a value.
It's listed here instead of being listed among the expressions
because it's effectively a conditional, though.</p>

<p>Suppose you want to write the following:</p>
<pre>
if (test_expression)
    var = if_expression;
else
    var = else_expression;
    
</pre>

<p>You can write that in a much more condensed way:</p>
<pre>
var = test_expression ? if_expression : else_expression;
e.g.
    name = day == 2 ? "tuesday" : "another day";
    
</pre>

<p>Opinions vary as to whether writing the conditional with this
operator makes the code easier or harder to read. A common rule of
thumb is that one use of the <code>?:</code> operator makes code
clearer, but that several in a single statement only makes it
worse. Something like this <i>definitely</i> isn't an
improvement:</p>
<pre>
name = day == 2 ? time == 18 ? "miller time" : "tuesday" : "another day";
    
</pre>

<h3><a name="SEC3.2.11" href="index.html#SEC3.2.11" id=
"SEC3.2.11">Loop statements</a></h3>

<p>There are two loop statements in LPC which incorporate the use
of conditional statements within them. That means they can be
programmed to execute only until a certain condition is true.</p>

<h4><a name="SEC3.2.11.1" href="index.html#SEC3.2.11.1" id=
"SEC3.2.11.1">The for statement</a></h4>

<p>If you want a counter or an iterator, you should usually use the
<b>for</b> statement. The syntax is as follows:</p>
<pre>
for (initalize_statement ; test_expression ; end_of_loop_statement)
    body_statement;
    
</pre>When first entered, the <code>for</code> statement executes
the <b>initialize_statement</b> part. This part usually is used to
initialize counters or values for the loop itself. Then the first
loop starts. Every loop starts by executing the
<b>test_expression</b> and examining the result. This is a truth
conditional, so any answer not equal to <code>0</code> or
<code>nil</code> will cause the loop to be run. If the test
expression is true then the <b>body_statement</b> is executed,
immediately followed by the <b>end_of_loop_statement</b>. In the
<b>body_statement</b> you usually do what you want to have done for
this iteration. In the <b>end_of_loop_statement</b> you usually
increment or decrement counters as needed to prepare them for the
<b>test_expression</b> in the next loop.

<p>Throughout the previous section I used the word <i>usually</i> a
lot. This is because you don't <i>have</i> to do it that way,
there's no rule forcing you to make use of the statements in the
way I said. For the moment let's stick to the regular way of using
the <b>for-statement</b>. Later on I'll describe more refined
techniques, and you can discover your own as well.</p>

<p>Assume you want to compute the sum of all integers from 7 to 123
and don't know the formula ((x2^2 + x1^2) / 2). The most
straightforward way of doing that is a loop.</p>
<pre>
result = 0;
for (count = 7 ; count &lt; 124 ; count++)
    result += count;
    
</pre>

<p>First of all, <code>result</code> is set to 0. Then the actual
<code>for</code> statement is entered. It begins by setting the
variable count to 7. Then the loop is entered, beginning by testing
if count (= 7) is less than 124. It is, so <code>result</code> has
count added to it. Then count is incremented and the loop is
entered again. This goes on until the count value reaches 124.
Since that isn't less than 124 the loop is ended.</p>

<p>The loop form above is pretty standard in C, but you may have
realized there's another way you can write the same thing:</p>
<pre>
result = 0;
for (count = 7 ; count &lt;= 123 ; count++)
    result += count;
    
</pre>This way works fine too, and you may find it more
understandable. Then again, you may not.

<p>Please note that the value of count after the <code>for</code>
statement will be 124 and <i>not</i> 123. The
<b>test_expression</b> must evaluate to <b>false</b> in order for
the loop to end, and in this case the value for count then must be
124. This is true for <i>both</i> ways of writing the loop
above!</p>

<h4><a name="SEC3.2.11.2" href="index.html#SEC3.2.11.2" id=
"SEC3.2.11.2">The while statement</a></h4>

<p><a name="IDX42" id="IDX42"></a> The <b>while</b> statement is
pretty straightforward. You can probably guess from its name what
it does. The statement will perform another statement over and over
until a given <code>while</code> expression returns false. The
syntax is:</p>
<pre>
while (&lt;test expression&gt;)
    
</pre>

<p>Note carefully that the test expression is checked first of all,
before running the statement the first time. If it evaluates as
false the first time, the body is never executed.</p>
<pre>
a = 0;
while (a != 4)
{
    a += 5;
    a /= 2;
}
    
</pre>

<h3><a name="SEC3.2.12" href="index.html#SEC3.2.12" id=
"SEC3.2.12">The break and continue statement</a></h3>

<p><a name="IDX43" id="IDX43"></a> <a name="IDX44" id="IDX44"></a>
Sometimes during the execution of <code>switch</code>,
<code>for</code> or <code>while</code> statements it becomes
necessary to abort execution of the block code, and continue
execution outside. To do that you use the <code>break</code>
statement. It stops the execution of that block and continues after
it.</p>
<pre>
while (end_condition &lt; 9999)
{
    /* If the time() function returns 29449494, abort execution */
    if (time() == 29449494)
        break;

    &lt; code &gt;
}

/* Continue here both after a break or when the full loop is done. */
&lt; code &gt;
    
</pre>

<p>Sometimes you merely want to start over from the top of the
<code>for</code> or <code>while</code> loop you're running. To do
that, you use the <code>continue</code> statement.</p>
<pre>
/* Add all even numbers */
sum = 0;
for (i = 0 ; i &lt; 10000 ; i++)
{
    /* Start from the top of the loop if 'i' is an odd number */
    if (i % 2)
         continue;

    sum += i;
}
    
</pre>Notice that the <code>i++</code> is executed when the loop is
continued. Only the <code>sum += i;</code> is skipped.

<h3><a name="SEC3.2.13" href="index.html#SEC3.2.13" id=
"SEC3.2.13">Arrays and Mappings</a></h3>

<p>It's time to dig deeper into the special types <b>array</b> and
<b>mapping</b>. For each of these data types there exist a number
of useful functions and operators that manipulate them and extract
information from them. Some of those functions and operators won't
be described in more detail until later.</p>

<h4><a name="SEC3.2.13.1" href="index.html#SEC3.2.13.1" id=
"SEC3.2.13.1">How to declare and use arrays</a></h4>

<p><a name="IDX45" id="IDX45"></a> Arrays really aren't arrays in
the proper sense of the word. They can better be seen as lists with
fixed order. The difference is that arrays can't usually be
manipulated easily, while LPC arrays have a rich set of operations
to reorder them, insert into them and otherwise manipulate
them.</p>

<p>Arrays are type-specific. This means that an array of a certain
type only can contain variables of that single type. All arrays are
one-dimensional, which means you can't declare an array which is
like a 2- or 3-dimensional grid rather than a list. However, the
<code>mixed</code> type takes care of these limitations. You can
also declare an array of arrays, which also takes care of the
problem. A mixed variable can act as an array containing any data
type, even other arrays. As a rule you should try to use properly
typed arrays to minimize the probabilities of programming mistakes.
When that's not possible, though, you can use the mixed type.</p>

<p>You declare an array like this:</p>
<pre>
&lt;type&gt; *&lt;array name&gt;;
e.g.
    int *my_arr, *your_arr;
    float *another_arr;
    object *ob_arr;
    
</pre>

<p>The initial values of these declared arrays is <code>nil</code>,
<i>not</i> an empty array. I repeat: they are initialized to nil
and <i>not</i> to an empty array. Keep this in mind!</p>

<p>You can allocate and initialize an array like this:</p>
<pre>
&lt;array&gt; = ({ elem1, elem2, elem3, ..., elemN });
e.g.
    int *my_arr;

    my_arr = ({ 1, 383, 5, 391, -4, 6 });
    
</pre>

<p>You can allocate an array of type <code>mixed</code> with the
<code>allocate</code> function, like this:</p>
<pre>
&lt;array&gt; = allocate(&lt;num of elements&gt;);
e.g.
    mixed *some_array;

    some_array = allocate(4);
    some_array[0] = "Upper Slavonia";
    some_array[1] = ({ 1, 2, 7, 9 });
    some_array[2] = ([ "bob" : 7 ]);
    some_array[3] = 7;
    
</pre>

<p>To access members of the array, use brackets after the variable
name:</p>
<pre>
&lt;data variable&gt; = &lt;array&gt;[&lt;index&gt;];
e.g.
    val = my_arr[3];

    val2 = some_array[1][3];
    
</pre>

<p>LPC, like C, starts counting from array index 0. That means the
index to the fourth value in an array is 3.</p>

<p>To set the value of an existing position to a new value, simply
set it using the <code>=</code> operator.</p>
<pre>
    my_arr[3] = 22;     /* =&gt; ({ 1, 383, 5, 22, -4, 6 }) */
    my_arr[3] = 391;    /* =&gt; ({ 1, 383, 5, 391, -4, 6 }) */
    
</pre>

<p>If you want to copy a subset of an array you can specify a range
of indices within the brackets. This is called an <b>array
slice</b>.</p>
<pre>
&lt;array variable&gt; = &lt;array&gt;[&lt;start_range&gt;..&lt;end_range&gt;];
e.g.
    your_arr = my_arr[1..3];
    
</pre>This will result in <code>your_arr</code> becoming the new
array <code>({ 383, 5, 391 });</code> If you give a new value to an
old array, the previous array is lost.
<pre>
e.g.
    my_arr = ({ });
    
</pre>

<p>This code will result in <code>my_arr</code> holding an empty
array. The old array is deallocated and the memory previously used
is reclaimed by the driver.</p>

<p>If you index outside an array, an error occurs and execution in
the object is aborted. However, range indexing outside the array
does not result in an error, the range is then only constrained to
fall within the array. So, for instance, if <code>my_arr</code> is
an empty array, the code <code>my_arr[3..7]</code> will return an
empty array.</p>

<p>Concatenating (adding) arrays to each other is most easily done
with the <code>+</code> operator. Simply add them as you would
numbers. The <code>+=</code> operator works fine as well.</p>
<pre>
my_arr = ({ 9, 3 }) + ({ 5, 10, 3 }); /* =&gt; ({ 9, 3, 5, 10, 3 }) */
    
</pre>

<p>Removing elements from an array is most easily done with the
<code>-</code> or <code>-=</code> operator. Be aware that the
operator that will remove <i>all</i> items found that match the
item you want to remove, not just one.</p>
<pre>
my_arr -= ({ 3, 10 }); /* =&gt; ({ 9, 5 }) */
    
</pre>

<p>If you want to remove a single item somewhere in the array that
might have been repeated, you should use the range operator.</p>
<pre>
my_arr = ({ 9, 3, 5, 10, 3 });
my_arr = my_arr[0..0] + my_arr[2..4]; /* =&gt; ({ 9, 5, 10, 3 }) */
    
</pre>

<p>Be careful of the following difference. One is a list, the other
an integer:</p>
<pre>
    &lt;array&gt; my_arr[0..0]   /* = ({ 9 }) */
    &lt;int&gt;   my_arr[0]      /* = 9 */
    
</pre>

<p>This means that if you wrote the above code as follows, it
wouldn't work:</p>
<pre>
my_arr = my_arr[0] + my_arr[2..4];
    
</pre>

<p>Instead, it would warn you that you can't add an integer to an
array.</p>

<p>You can leave one end of the array slice unspecified, which will
use the beginning or end of the array. For instance:</p>
<pre>
my_arr = my_arr[..2] + ({ 3, 7, 4 }) + some_array[3..];
    
</pre>

<p>The code above would use elements 0 through 2 of my_arr, add ({
3, 7, 4 }) to the end, and then add all elements of some_array,
starting at the fourth.</p>

<h4><a name="SEC3.2.13.2" href="index.html#SEC3.2.13.2" id=
"SEC3.2.13.2">How to declare and use Mappings</a></h4>

<p><a name="IDX47" id="IDX47"></a> Mappings are lists of associated
values. They are of <code>mixed</code> type, meaning that the
different indices and the different values can be of varying types
within the same mapping.</p>

<p>Mappings can use any kind of data type for either index or
value. The index part of the mapping in a single mapping must
consist of unique values. There cannot be two indices of the same
value as one would overwrite the other.</p>

<p>You can declare a mapping just like any other variable, so let's
start with a few declarations for later use:</p>
<pre>
mapping my_map;
int     value;
    
</pre>

<p>Allocating and initializing can be done in two different
ways:</p>
<pre>
1:  &lt;mapping_var&gt; = ([ &lt;index1&gt;:&lt;value1&gt;, &lt;index2&gt;:&lt;value2&gt;, ... ]);

2:  &lt;mapping_var&gt;[&lt;index&gt;] = value;
    
</pre>

<p>The first is straightforward and easy.</p>
<pre>
1: my_map = ([ "adam":5, "bertil":8, "cecar":-4 ]);
    
</pre>

<p>In the second case, if a given index doesn't exist in the
mapping then it is created when referenced. If it does exist then
the value for that index is replaced with the one being
assigned.</p>
<pre>
2: my_map["adam"] = 1;    /* Creates the pair "adam":1 */
   my_map["bertil"] = 8;  /* Creates the pair "bertil":8 */
   my_map["adam"] = 5;    /* Replaces the old value in "adam" with 5. */
        ...
    
</pre>

<p>Unlike arrays there's no order in a mapping. The values are
stored in a way that makes finding the values as quick as possible.
There are functions that will allow you to get the component lists
(the indices or values) from a mapping but keep in mind that they
can be in <i>any</i> order and are not guaranteed to remain the
same from call to call. In practice they only change order when you
add or remove an element, but it's best not to rely on that.</p>

<p>You can merge mappings with the <code>+</code> and
<code>+=</code> operators, just as with arrays.</p>
<pre>
my_map += ([ "david":5, "erik":33 ]);
    
</pre>

<p><a name="IDX48" id="IDX48"></a> Removing items in a mapping is
simple. You can assign <code>nil</code> to that index of the array.
Doing so will delete the index/value pair:</p>
<pre>
my_map["david"] = nil;
    
</pre>

<p>Individual values can be obtained through simple indexing:</p>
<pre>
value = my_map["cecar"]; /* =&gt; -4 */
    
</pre>

<p>Indexing a value that doesn't exist will <i>not</i> generate an
error, only the value <code>nil</code>. Be <i>very</i> careful of
this since you might indeed have legal values of nil in the mapping
as well -- for instance, a value of <code>nil</code> might mean
that the index has no value part, or instead that the value indeed
<i>is</i> <code>nil</code>:</p>
<pre>
value = my_map["urk"]; /* =&gt; nil */
    
</pre>If you need to be certain, there is a function called
<code>map_indices</code> which will return the list of indices. You
can check to see if the index exists that way:
<pre>
if(map_indices(my_map) &amp; ({ "urk" })) {
    DRIVER-&gt;message("Urk is a member of the array!\n");
}
    
</pre>
<hr size="2">

<h2><a name="SEC3.3" href="index.html#SEC3.3" id="SEC3.3">The
preprocessor</a></h2>

<p>The preprocessor isn't a part of the LPC language proper. It's a
special process that is run before the actual compilation of the
program occurs. It can be seen as a very smart string translator.
Specified strings in the code are replaced by other strings.</p>

<p>All preprocessor directives are given as strings starting with
the character <tt>#</tt> on the first non-whitespace column of the
line. It's considered good practice to put preprocessor directives
on the very far left of the code, with the <tt>#</tt> in the very
first column.</p>

<h3><a name="SEC3.3.1" href="index.html#SEC3.3.1" id="SEC3.3.1">The
#include statement</a></h3>

<p><a name="IDX49" id="IDX49"></a> This is by far the most common
preprocessor command. It simply tells the preprocessor to replace
that line with the contents of an entire other file before going
any further.</p>

<p>Data you put in included files is usually data that won't ever
change and that you'll be referencing in several files. Instead of
having to copy and paste the same lines into multiple places and
maintaining multiple copies, you simply collect that data in an
include file and include it in the program files as appropriate.
Included file names traditionally end in <tt>.h</tt>.</p>

<p>The syntax for inclusion is simple:</p>
<pre>
#include &lt;standard_file&gt;
#include "special_file"
    
</pre>

<p>Note the absence of a <code>;</code> after the line.</p>

<p>There are two different ways to write this. Which you use
depends on where the file is that you want to include. There are a
usually standard include files which may be in any of several
different directories. Rather than having to remember exactly where
they are, you can just give the name of the file you want to
include if it's in a standard include directory.</p>
<pre>
#include &lt;limits.h&gt;
#include &lt;types.h&gt;
    
</pre>

<p>If you want to include files that aren't in the standard include
path, for example files of your own, you have to specify where they
are. You can do that either relative to the position of the file
that uses it or by an absolute path. (NOTE: does DGD allow
non-absolute include paths?)</p>
<pre>
#include "/d/Genesis/login/login.h"
#include "my_defs.h"
#include "/sys/adverbs.h"     /* Same as the shorter one above */
    
</pre>

<p>When you include standard files, <i>always</i> use the
&lt;&gt;-path notation. Not only is it shorter and easier to
distinguish, but also if the files move around then files included
with relative or absolute syntax won't be found. If you use the
special include syntax then they will be found in any standard
directory, even if they move between them.</p>

<p>It's possible to include LPC files -- entire files full of code.
Doing so is normally considered <i>very</i> bad form. Error
handling usually has a bad time tracing errors in included files --
there are frequently problems with line numbers. Since you include
the uncompiled code into several different objets, you will waste
memory and CPU for these identical functions and variables. It also
tends to be harder to figure out where functions are defined.</p>

<p>What does the extension of the file name really have to do with
the contents then? Technically, nothing at all. But the convention
is to keep functions in <tt>.cc</tt> files and definitions in
<tt>.h</tt> files. Many mudlibs enforce this, and accept only
certain file suffixes for compilation or other tasks.</p>

<h3><a name="SEC3.3.2" href="index.html#SEC3.3.2" id="SEC3.3.2">The
#define statement</a></h3>

<p><a name="IDX50" id="IDX50"></a> <a name="IDX51" id="IDX51"></a>
#define is a very powerful <b>macro</b> or preprocessor command
that can be abused endlessly. It's recommended that you use it with
caution and only for simple tasks. Using it for complex tasks tends
to make reading or debugging your code quite difficult.</p>

<p>The syntax is as follows:</p>
<pre>
#define &lt;pattern&gt; &lt;substitute pattern&gt;
#undef &lt;pattern&gt;
    
</pre>

<p>Any text in the file that matches <code>&lt;pattern&gt;</code>
will be replaced with <code>&lt;substitute pattern&gt;</code>
before compilation occurs. A <code>#define</code> is valid from the
line it is found on until the end of the file or an
<code>#undef</code> command that removes it.</p>

<p>Although the preprocessor allows #define labels to be any sort
of legal text, it is customary to use only capital letters. This is
so that they will be easily distinguishable as what they are.</p>

<p>Place all defines in the beginning of the file. Again, the
compiler doesn't enforce this but it's a very good idea. It
guarantees not only that they are easy to find, but also that
they're usable throughout the file.</p>

<p>Common defines include paths, names and above all constants of
any kind. By defining them, you avoid writing them over and
over.</p>
<pre>
#define MAX_LOGIN  100          /* Max logged on players */
#define MY_USER    "/usr/System/my_user" /* My user object */
#define GREET_TEXT "Welcome!"   /* The login message */
    
</pre>

<p>Anywhere the pattern strings above occur in the file where
they're defined (and any file that includes it), they will be
replaced by the defined value above. The substitution includes the
comments above, but they're ignored by the compiler.</p>
<pre>
DRIVER-&gt;message(GREET_TEXT + "\n");
    
</pre>

<p>If a macro extends beyond the end of the line you can terminate
the lines with a <code>\</code>. That continues the macro onto the
next line. However, you <i>must</i> put the newline immediately
after the <code>\</code>. There may not be spaces or other
characters between the backslash and the newline.</p>
<pre>
#define LONG_DEFINE  "beginning of string \
                      and end of the same" 
    
</pre>

<p>Function-like defines are fairly common and often abused. It's
important to write macros such that every argument to the macro is
enclosed in parenthesis where it's used. If you don't do that you
can end up with some very strange results.</p>
<pre>
1: #define MUL_IT(a, b) a * b        /* Wrong */
2: #define MUL_IT(a, b) (a * b)      /* Not enough */
3: #define MUL_IT(a, b) ((a) * (b))  /* Correct */
    
</pre>

<p>What's the big difference? Look at this example:</p>
<pre>
result = MUL_IT(2 + 3, 4 * 5) / 5;

   Expanded with the three different macros, this becomes:

1: result = 2 + 3 * 4 * 5 / 5;       /* = 14, Wrong */
2: result = (2 + 3 * 4 * 5) / 5      /* = 12, Still wrong */
3: result = ((2 + 3) * (4 * 5)) / 5  /* = 20, Correct! */
    
</pre>

<p>Common problems with defined constants and functions include
badly formulated macros, complicated macros used inside other
macros (making the code almost impossible to understand) or
humongous arrays or mappings in defines that are used often. The
basic rule is to keep macros short and fairly simple.</p>

<h3><a name="SEC3.3.3" href="index.html#SEC3.3.3" id="SEC3.3.3">The
#if, #ifdef, #ifndef, #else and #elseif statements</a></h3>

<p><a name="IDX52" id="IDX52"></a> <a name="IDX53" id="IDX53"></a>
<a name="IDX54" id="IDX54"></a> <a name="IDX55" id="IDX55"></a>
<a name="IDX56" id="IDX56"></a> The commands above are all
preprocessor directives aimed at selecting certain parts of code
and perhaps removing others depending on the state of a
preprocessor variable.</p>

<p>The <code>#if</code> statement looks very much like a normal if
statement, but is written a bit differently.</p>

<p>Assume you <i>may</i> have one of the following definitions
somewhere:</p>
<pre>
#define code_VAR  2

or
        
#define code_VAR  3
    
</pre>

<p>Then you can write</p>
<pre>
#if code_VAR == 2
    &lt;code that will be kept only if code_VAR == 2&gt;
#else
    &lt;code that will be kept only if code_VAR != 2&gt;
#endif
    
</pre>

<p>You don't have to have the <code>#else</code> statement there at
all if you don't want to. You can simply use <code>#if</code> and
<code>#endif</code>.</p>

<p>It's sufficient to have the following statement to 'define' a
preprocessor pattern as existing:</p>
<pre>
#define code_VAR    /* This defines the existance of code_VAR */
    
</pre>

<p>Then you can use <code>#ifdef</code> to check for its existence,
like this:</p>
<pre>
#ifdef code_VAR
    &lt;code that will be kept only if code_VAR is defined&gt;
#else
    &lt;code that will be kept only if code_VAR isn't defined&gt;
#endif
</pre>

<p>or you can use #ifndef, which is essentially an #ifdef with an
extra "not" implied.</p>
<pre>
#ifndef code_VAR
    &lt;code that will be kept only if code_VAR isn't defined&gt;
#else
    &lt;code that will be kept only if code_VAR is defined&gt;
#endif
    
</pre>

<p>Again, the <code>#else</code> is optional.</p>

<p>The <code>#if/#ifdef/#ifndef</code> preprocessor commands are
frequently used to add debug code that you don't want to have
activated all of the time, or code that will work differently
depending on other very rarely changing parameters. Since the
conditions have to be hard-coded in the file and can't change
easily at runtime, most features will use a regular <code>if</code>
instead of an <code>#if</code>.</p>
