<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title> DGD LPC Textbook </title>
  </head>

  <body text="#000000" bgcolor="#DDDDDD" link="#0000EF" vlink="#51188E"
	alink="#FF0000">

    <h1> LPC:  The LPMUD Programming Language </h1>
    <h2> DGD edition </h2>

    <p> Copyright 1996, 2003 Ronny Wikh and Noah Gibbs </p>

    <hr size="4">

    <h3><a name="SEC3.2.6" href="index.html#SEC3.2.6">
	Scope and prototypes</a></h3>

    <p>
      <b>Scope</b> is a term defining where a function or variable
      declaration is valid. Since programs are read top down (just
      like you read this page), declarations of functions and
      variables are available to the below the actual
      declaration. However, the scope might be further limited.
    </p>

    <p>
      A variable that is declared inside a function is only valid
      until the end of that function (the terminating <code>}</code>)
      is reached.  If it's declared in a block inside that function,
      such as inside a <code>for</code> loop, it's only valid until
      the end of that block (the <code>}<code> matching the beginning
      <code>{</code> of that block).
    </p>

    <pre>
&lt;top of file&gt;
int GlobCount;

/* Only GlobCount is available here */

void
var_func(int arg)
{
    int var_1;

    /* GlobCount, arg and var_1 are available here */
    &lt; code &gt;

    {
        string var_2;

        /* GlobCount, arg, var_1 and var_2 are available in this block */
        &lt; code &gt;
    }

    /* GlobCount, arg and var_1 are available here */
    &lt; code &gt;

    {
        int var_2;
        mapping var_3;

        /* GlobCount, arg, var_1, var_2 and var_3 are available here
          Note that this var_2 is a NEW var_2, an int not a string */
        &lt; code &gt;
    }

    /* GlobCount, arg and var_1 are available here */
    &lt; code &gt;
}

/* Here only GlobCount and the function var_func are available */
    </pre>

    <p>
      Function declarations follow the same rule of scope, though you
      can't declare a function inside another function.  Suppose you
      have these two functions where the first uses the second:
    <pre>
int
func_1()
{
    &lt; code &gt;
    func_2("test");
}

void
func_2(string data)
{
    &lt; code &gt;
}
    </pre>
  </p>

    <p>
      Then you have a problem, because the first function tries to use
      the second function before it is declared. This may result in an
      error message, and it's bad practice in any case.  To take care
      of this you can rearrange the functions so that
      <code>func_2</code> comes before <code>func_1</code> in the
      listing.  This isn't always the best layout, and it isn't always
      possible.  It's usually better to write a <b>function
      prototype</b>.  The function prototype should be placed at the
      top of the file after the <code>inherit</code> and
      <code>#include</code> statements (described later) but
      <i>before</i> any code.  It should look very much like the
      function declaration itself. In this case:

    <pre>
&lt; top of file, <code>inherit</code> and <code>#include</code> statements &gt;

void func_2(string data);

&lt; the actual code &gt;
    </pre> </p>


    <h3><a name="SEC3.2.7" href="index.html#SEC3.2.7">
	Operator expressions</a></h3>

    <p>
      The LPC language defines a large set of operator expressions.
      These are simply expressions that operate on other
      expressions. What follows here is a list of them.  This section
      uses condensed notation to save space and reduce complexity.
    </p>

<dl compact>

<dt><tt>E</tt>
<dd> Any expression, including compound expressions. </dd>

<dt><tt>V</tt>
<dd> A variable. </dd>
</dl>


    <h4><a name="SEC3.2.7.1" href="index.html#SEC3.2.7.1">
	Miscellaneous operators</a></h4>

    <dl compact>
      <dt>(E) </dt>

      <dd>
	The expression inside the parentheses is evaluated before
	anything outside the parenthesis. This is useful for isolating
	expressions that need to be done in a specific order.  It's
	also useful when you are uncertain about operator precedence,
	or when you want to make it obvious to readers of your code
	what the precedence is.
      </dd>

      <dt>E1, E2</dt>

      <dd>
	<a name="IDX13"></a>

	The first expression is evaluated first and the result stored,
	then E2 is evaluated and the result is thrown away.  Finally,
	the stored result of E1 is returned as the value of the entire
	expression.  The statement <code>a = 1, 2, 3;</code> will set
	'a' to contain '1'.
      </dd>

      <dt>V = E</dt>

      <dd>
	<a name="IDX14"></a>

	The variable is given the value of the expression. The
	resulting value of this entire expression is also the value of
	E.  For instance, <code>a = b = 4;</code> will set a and b to
	be 4. It can also be written <code>a = (b = 4)</code> to
	illustrate the order of execution.
      </dd>

    </dl>


    <h4><a name="SEC3.2.7.2" href="index.html#SEC3.2.7.2">
	Arithmetic operators</a></h4>

    <dl compact>

      <dt>E1 + E2</dt>

      <dd>
	<a name="IDX15"></a>

	<p>
	  The expressions are evaluated and the results added to each
	  other.  You can add integers, floats, strings, arrays and
	  mappings.  Strings, arrays and mappings are simply
	  concatenated - pasted together to the end of the first
	  argument.
	</p>

	<p>
	  It's also possible to add integers to strings, they will
	  then be converted to strings and pasted to the end of the
	  string.
	</p>
      </dd>

      <dt>E1 - E2</dt>

      <dd> <a name="IDX16"></a>

	<p>
	  E2 is subtracted from E1.  You can subtract integers, floats
	  and any type from arrays of the same type. For arrays the
	  item, if it exists in the array it is subtracted from, is
	  removed from the array. If it doesn't exist in the array,
	  the array is returned intact.
	</p>
      </dd>

      <dt>E1 * E2</dt>

      <dd>
	<a name="IDX17"></a>

	E1 is multiplied by E2.  This only works on integers and floats.
      </dd>

      <dt>E1 / E2</dt>

      <dd>
	<a name="IDX18"></a>

	E1 is divided by E2.  This only works on integers and floats.
      </dd>

      <dt>E1 % E2</dt>

      <dd>
	<a name="IDX19"></a>

	The remainder (also called the modulus) of the expression 'E1
	/ E2' is returned.  This only works with integers.  For
	instance, <code>14 % 3</code> will yield 2 as the remainder.
      </dd>

      <dt>-E</dt>

      <dd>
	Return E, negated arithmetically.  This only works on
	integers and floats.  For either one, the value returned
	is equal to zero minus E, or negative E.
      </dd>

      <dt>E++, ++E</dt>

      <dd>
	<a name="IDX20"></a>

	<p>
	  The expression E is incremented by one. If the operator is
	  in front of the expression (called &quot;prefix&quot;) then
	  the incremented value is returned, otherwise the previous
	  value is.  For instance, if the variable <code>ctr</code> is
	  equal to 3 then <code>++ctr</code> would return 4 and
	  <code>ctr++</code> would return 3.  This only works on
	  integers.
	</p>

	<p>
	  The value of <code>++a</code> is also an lvalue, which means
	  it can be assigned to.  If you don't immediately know what
	  that means, don't do that.
	</p>

	<pre>
'a = 3; b = ++a;' will yield the result 'a = 4, b = 4', while
'a = 3; b = a++;' will yield the result 'a = 4, b = 3'.
	</pre>
      </dd>

      <dt>E--, --E</dt>

      <dd>
	<a name="IDX21"></a>

	The expression 'E' is decremented by one. If the operator is
	in front of the expression, the decrement is done before the
	value is returned, otherwise afterwards.  This only works
	on integers.

	<pre>
'a = 3; b = --a;' will yield the result 'a = 2, b = 2', while
'a = 3; b = a--;' will yield the result 'a = 2, b = 3'.
	</pre>
      </dd>
    </dl>


    <h4><a name="SEC3.2.7.3" href="index.html#SEC3.2.7.3">
	Boolean operators</a></h4>

    <p>
      Boolean operators are applicable only to integers with the
      exception of the <code>&amp;</code> and <code>|</code>
      operators, which also work on arrays.  Internally an integer is
      32 bits long.  However, in the following examples I will only
      show the ten last bits as the others are 0 and can be ignored
      with the one exception of the <code>~</code>-operator.
    </p>

    <dl compact>

      <dt>E1 &amp; E2 </dt>

      <dd>
	<a name="IDX22"></a>

	E1 and E2.  Every bit which is set in both E1 and E2 will also
	be set in the result.  Any bit which is zero in either one
	will be zero in the result.

<pre>
1011101001   (= 745)
1000100010 &amp; (= 546)
------------
1000100000   (= 544) =&gt; 745 &amp; 546 = 544
</pre>

	Used on two arrays, this function will return a new array that
	holds all elements that are members of both of the argument
	arrays.  Thus, it performs a kind of set-intersection on the
	arrays.
      </dd>

      <dt>E1 | E2 </dt>

      <dd>
	<a name="IDX23"></a>

	E1 or E2.  Every bit which is set in either E1 or E2 will be
	set in the result.  Any bit which is zero in both E1 and E2
	will be zero in the result.

<pre>
1011101001   (= 745)
1000100010 | (= 546)
------------
1011101011   (= 747) =&gt; 745 | 546 = 747
</pre>

	Used on two arrays, this function will return an array
	containing any element which is in either one of the
	original two arrays.  If E1 and E2 share no members in
	common, this is the same as E1 + E2.
      </dd>

      <dt>E1 ^ E2</dt>

      <dd>
	<a name="IDX24"></a>

	E1 xor (exclusive or) E2.  A bit which is zero in both or
	one in both is zero in the result.  A bit which is set in
	either E1 or E2, but not both, is one in the result.

<pre>
1011101001   (= 745)
1000100010 ^ (= 546)
------------
0011001011   (= 203) =&gt; 745 ^ 546 = 203
</pre>
      </dd>

      <dt>~E</dt>

      <dd>
	<a name="IDX25"></a>

	1-complement of E (invert E).  This is a unary operator,
	meaning it takes only one argument.  A bit which is one in the
	argument will be zero in the result and vice-versa.

<pre>
00000000000000000000001011101001 ~ (= 745)
----------------------------------
11111111111111111111110100010110   (= -746) =&gt; ~745 = -746
</pre>

	The above example might be hard to understand unless you
	really know your binary arithmetic. However, trust me when I
	say that this is <i>not</i> a typo, it's the way it should
	look.  ~745 is different from -745 -- one is a one's
	complement and the other is a two's complement.  Read about
	twos-complement binary arithmetic and all will be made clear.
      </dd>

      <dt>E1 &lt;&lt; E2 </dt>

      <dd>
	<a name="IDX26"></a>

	E1 is shifted left E2 steps.  This multiplies the value of E1
	by two to the power of E2.  For instance, if E2 was three,
	<code>E1 &lt;&lt; E2</code> would be <code>E1 * 8</code>.

	<pre>
5 &lt;&lt; 4 =&gt; 101(b) &lt;&lt; 4 = 1010000(b) = 80
	</pre>
      </dd>

      <dt>E1 &gt;&gt; E2 </dt>

      <dd>
	<a name="IDX27"></a>

	E1 is shifted right E2 steps.  This divides the value of E1 by
	two to the power of E2, rounded down.  For instance, if E2 was
	five, <code>E1 &gt;&gt; E2</code> would be equal to <code>E1 /
	32</code>.

	<pre>
1054 &gt;&gt; 5 =&gt; 10000011110(b) &gt;&gt; 5 = 100000(b) = 32
	</pre>
      </dd>
    </dl>


    <h4><a name="SEC3.2.7.4" href="index.html#SEC3.2.7.4">
	Conditional (logical) operators</a></h4>

    <dl compact>

      <dt>E1 || E2 </dt>

      <dd>
	<a name="IDX28"></a>

	Returns true if E1 or E2 evaluates as true. Will not evaluate
	E2 if E1 is true.  The fact that it won't evaluate the second
	argument if the first is true is called &quot;short circuit
	evaluation&quot;.
      </dd>

      <dt>E1 &amp;&amp; E2 </dt>

      <dd>
	<a name="IDX29"></a>

	Returns true if both E1 and E2 evaluates as true.  Will not
	evaluate E2 if E1 is false.  The fact that it won't evaluate
	the second argument if the first is false is called
	&quot;short circuit evaluation&quot;.
      </dd>

      <dt>!E</dt>

      <dd>
	<a name="IDX30"></a>

	Returns true if E is false and vice versa.
      </dd>

    </dl>


    <h4><a name="SEC3.2.7.5" href="index.html#SEC3.2.7.5">
	Comparative operators</a></h4>

    <dl compact>

      <dt>E1 == E2</dt>

      <dd>
	<a name="IDX31"></a>

	Returns true if E1 is equal to E2.  This operator can be used
	on all types, but see the special section later on arrays and
	mappings.  Equality works differently on them than you might
	think.
      </dd>

      <dt>E1 != E2</dt>

      <dd>
	<a name="IDX32"></a>

	Returns true if E1 isn't equal to E2.  This operator can be
	used on all kinds of types, but see the special section later
	on arrays and mappings.  It works differently on them than you
	might think.
      </dd>

      <dt>E1 &gt; E2 </dt>

      <dd>
	<a name="IDX33"></a>

	Returns true if E1 is greater than E2.  This operator can be
	used on all types except arrays and mappings.
      </dd>

      <dt>E1 &lt; E2</dt>

      <dd>
	<a name="IDX34"></a>

	Returns true if E1 is less than E2.  Can be used on all types
	except arrays and mappings.
      </dd>

      <dt>E1 &gt;= E2 </dt>

      <dd>
	<a name="IDX35"></a>

	Returns true if E1 is greater or equal to E2.  This operator
	can be used on all types except arrays and mappings.
      </dd>

      <dt>E1 &lt;= E2 </dt>

      <dd>
	<a name="IDX36"></a>

	Returns true if E1 is less or equal to E2.  This operator can
	be used on all types except arrays and mappings.
      </dd>

    </dl>


    <h3><a name="SEC3.2.8" href="index.html#SEC3.2.8">
	Prefix allocation</a></h3>

    <p>
      <a name="IDX37"></a>

      All of the arithmetic and boolean operator expressions can be
      written in a shorter way if what you want to do is use an
      operator on a variable and a value (or two variables) and then
      store the result in the variable.
    </p>

    <p>
      Say that what you want to do is this <code>a = a + 5;</code>.  A
      much neater way of writing that is <code>a += 5;</code>.  This
      does exactly the same thing with less keystrokes and less chance
      of error in typing.  Many people also find it more readable.
    </p>

    <p>
      You write all the others in the same way.  So the result
      variable comes first, then the operator directly followed by
      <code>=</code> and then the value to operate on.  Make sure not
      to put a space between the operator and the equals sign, and
      make sure to put the operator before the equals sign.
    </p>

<pre>
a &gt;&gt;= 5;       /* a = a &gt;&gt; 5; */
b %= d + 4;    /* b = b % (d + 4); */
c ^= 44 &amp; q;   /* c = c ^ (44 &amp; q); */

c =+ 7;      /* c = (+7), probably not what you wanted. */
c + = 7;     /* Error!  Don't use the extra space. */
</pre>


    <h3><a name="SEC3.2.9" href="index.html#SEC3.2.9">
	Precedence and Order of evaluation</a></h3>

    <p>
      The table below summarizes the rules for precedence and
      associativity of all operators, including those which we have
      not yet discussed.  Operators on the same line have the same
      precedence, rows are in order of decreasing precedence, so, for
      example, <code>*</code>, <code>/</code> and <code>%</code> all
      have the same precedence, which is higher than that of
      <code>+</code> and <code>-</code>.
    </p>

    <p>
      Note that the precedence of the bitwise logical operators
      <code>&amp;</code>, <code>^</code> and <code>|</code> falls
      below <code>==</code> and <code>!=</code>. This implies that
      bit-testing expressions like the one below must be fully
      parenthesized to give proper results.
    <pre>
if ((x &amp; MASK) == 0) ...
    </pre>
  </p>

    <dl compact>
      <dt>() [] </dt>

      <dd> Left to right </dd>

      <dt>! ~ ++ -- - (type) * &amp; </dt>

      <dd> Right to left </dd>

      <dt>* / %</dt>

      <dd>Left to right</dd>

      <dt>+ -</dt>

      <dd>Left to right</dd>

      <dt>&lt;&lt; &gt;&gt; </dt>

      <dd> Left to right </dd>

      <dt>&lt; &lt;= &gt; &gt;=</dt>

      <dd> Left to right </dd>

      <dt>== != </dt>

      <dd> Left to right </dd>

      <dt>&amp; </dt>

      <dd> Left to right </dt>

      <dt>^</dt>

      <dd> Left to right </dd>

      <dt>|</dt>

      <dd> Left to right </dd>

      <dt>&amp;&amp;</dt>

      <dd> Left to right </dd>

      <dt>||</dt>

      <dd> Left to right </dd>

      <dt>?:</dt>

      <dd> Right to left </dd>

      <dt>= += == etc. </dt>

      <dd> Right to left </dd>

      <dt>,</dt>

      <dd> Left to right </dd>
    </dl>

    <p>
      Note that in the list, <code>(type)</code> denotes a typecast.
      Note also that in every case, a unary operator is higher
      precedence than its binary equivalent.  So the expression
      <code>-7 - 5</code> is equal to <code>(-7) - 5</code> instead
      of <code>-(7-5)</code>.
    </p>

    <hr>
    <a href="http://sourceforge.net">
      <img src="http://sourceforge.net/sflogo.php?group_id=48659&type=6"
	   width="210" height="62" border="0" alt="SourceForge.net Logo"></a>
    <address><a href="mailto:noah_gibbs@yaNOSPAMhoo.com">Noah Gibbs</a>
    </address>
    <!-- Created: Mon Jun 11 21:50:30 PDT 2001 -->
    <!-- hhmts start -->
Last modified: Tue Apr  8 22:13:17 PDT 2003
<!-- hhmts end -->
  </body>
</html>
