<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title> DGD LPC Textbook </title>
  </head>

  <body text="#000000" bgcolor="#DDDDDD" link="#0000EF" vlink="#51188E"
	alink="#FF0000">

    <h1> LPC:  The LPMUD Programming Language </h1>
    <h2> DGD edition </h2>

    <p> Copyright 1996, 2003 Ronny Wikh and Noah Gibbs </p>

    <hr size="4">

    <h1><a name="SEC4.0" href="index.html#SEC4.0">
	Essential LPC and Mudlib</a></h1>

    <p>
      This chapter will teach you what you need to know in order to
      actually produce code in the game environment. It will avoid the
      more complicated or inessential subjects, leaving them for
      chapter three.  This chapter contains more about the mudlib and
      the workings of the driver, knowledge necessary to produce
      working code in real situations.
    </p>

    <hr size=2>

    <h2><a name="SEC4.1" href="index.html#SEC4.1">
	4.1 A Peek at things to come</a></h2>

    <p>
      To present things on the screen for the player to read,
      the <code>message()</code> function is called on that player's
      user object.  Different mudlibs supply the user object in
      different ways.
    </p>

    <p>
      There are two special characters that are often used to format
      text, <tt>tab</tt> and <tt>newline</tt>.  They are written as
      <code>\t</code> and <code>\n</code> respectively within DGD
      strings.  The <tt>tab</tt> character inserts 8 space characters
      and <tt>newline</tt> breaks the line.
    </p>

    <pre>
void message(string text);
e.g.
    user->message(&quot;Hello there!\n&quot;);
    user->message(&quot;\tThis is an indented string.\n&quot;);
    user->message(&quot;This is a string\non several lines\n\tpartly\nindented.\n&quot;);

    /* The result is:

       Hello there!

               This is an indented string.

       This is a string
       on several lines
               partly
       indented.
     */
    </pre>


    <hr size=2>

    <h2><a name="SEC4.2" href="index.html#SEC4.2">
	LPC revisited</a></h2>

    <p>
      Let's go through more of the LPC constructs that we didn't
      finish in the LPC Basics section.  Now that you know the
      basics and can use them for simple scripts, it's time to
      find out more of what LPC can do.
    </p>


    <h3><a name="SEC4.2.1" href="index.html#SEC4.2.1">
	Function calls</a></h3>

    <p>
      There are two kinds of function calls, internal and
      external. We've only discussed internal calls so far.
    </p>

    <h4><a name="SEC4.2.1.1" href="index.html#SEC4.2.1.1">
	Making object-internal function calls</a></h4>

    <p>
      <a name="IDX57"></a>

      Making an internal function call is as simple as writing the
      function name and putting any arguments within parentheses
      afterwards. The argument list is simply a list of expressions,
      or nothing.  A function call is an expression if it returns a
      value.  A function call followed by a <code>;</code> is a
      statement.
    </p>

    <pre>
&lt;function&gt;(&lt;argument list&gt;);
e.g.
    pi = atan(1.0) * 4;
    </pre>


    <h4><a name="SEC4.2.1.2" href="index.html#SEC4.2.1.2">
	Making single object-external function calls</a></h4>

    <p>
      <a name="IDX58"></a>

      An external call is a call from one object into another. In
      order to do that you need an object reference to the object you
      want to call.  We haven't discussed exactly how you acquire an
      object reference yet, but assume for the moment that it already
      is done for you.  Object references (the same thing as object
      pointers) can be stored in variables of type
      <code>object</code>.
    </p>

    <pre>
mixed &lt;object reference/object path&gt;-&gt;&lt;function&gt;(&lt;argument list&gt;);
mixed call_other(&lt;ob ref/ob path&gt;, &quot;&lt;function&gt;&quot;, &lt;arg list&gt;);
e.g.
    /*
     * Assume that I want to call the function 'compute_pi' in the
     * object &quot;/d/Mydom/thewiz/math_ob&quot;, and that I also have the
     * proper object pointer to it stored in the variable 'math_ob'
     */
    pi = math_ob-&gt;compute_pi(1.0);
    pi = &quot;/d/Mydom/thewiz/math_ob&quot;-&gt;compute_pi(1.0);
    pi = call_other(math_ob, &quot;compute_pi&quot;, 1.0);
    pi = call_other(&quot;/d/Mydom/thewiz/math_ob&quot;, &quot;compute_pi&quot;, 1.0);
    </pre>

    <p>
      Note that you can either use the <code>call_other</code>
      function or just use the -&gt; notation.  One is syntactic sugar
      for the other.  The behavior is identical either way.  Note
      that if you use the <code>call_other()</code> form, you need
      to put quotes around the function name since you're actually
      supplying any string -- which can be a variable, or the
      result of a computation:
    <pre>
pi = call_other(math_ob, &quot;computer&quot; + &quot;_pi&quot;, 1.0);
    </pre>
  </p>

    <p>
      If the object you call hasn't been loaded into memory yet, it
      will be.  If it has a <code>create()</code> function that hasn't
      been called, that function will be called (note that the
      <code>create()</code> function may have a different name if DGD
      is configured differently).  If an external call is made to a
      function that doesn't exist in the object you call, nil will be
      silently returned without any error messages.
    </p>

    <p>
      If you use an object path (a string) instead of an object
      reference, the <b>master object</b> will be called.  The master
      object can contain data just like any of the clones, and is
      often a good place to store a central copy of information that
      all clones want to use without each one needing its own copy.
    </p>


    <h3><a name="SEC4.2.2" href="index.html#SEC4.2.2">
	Inheriting object classes</a></h3>

    <p>
      Assume that you want to code a door.  Doing that means that you
      have to create functionality that allows the opening and closing
      of a passage between two rooms. Perhaps you want to be able to
      lock and unlock the door, and perhaps you want the door to be
      transparent.  All of this must be taken care of in your code.
      Furthermore, you have to copy the same code and make small
      variations in description and use <i>every time</i> you want to
      make a new door.
    </p>

    <p>
      After a while you'll get rather tired of this, particularly
      because you'll find that other wizards have created doors of
      their own that work almost - but not quite - the same way your
      does, rendering some of your nifty objects and features useless
      anywhere but in your domain.
    </p>

    <p>
      The object oriented way of thinking is that instead of doing
      things over and over, you create a basic door object that can do
      all the things you want any door to be able to do. Then you just
      inherit this generic door into a specialized door object where
      you configure exactly what <i>it</i> should be able to do from
      the list of available options in the <b>parent</b> door.
    </p>

    <p>
      It is even possible to inherit several different objects in
      order to combine the functionality of several object types into
      one.  Be aware that if a class's parent objects define functions
      with the same names, they will clash.  It may not be easy to fix
      this problem, so avoid inheriting from more than one parent
      until you're reasonably sure what you're doing.
    </p>

    <p>
      The syntax for inheriting objects is very simple. In the top of
      the file you write this:
    </p>

    <pre>
[private] inherit [prefix] &quot;&lt;file path&gt;&quot;;
e.g.
	inherit &quot;/std/door&quot;;
	inherit &quot;/usr/common/object&quot;;
        private inherit foo &quot;/usr/bob/secret_parent&quot;;
    </pre>

    <p>
	
      Note that this is <i>not</i> a preprocessor command, it is a
      statement, so it does <i>not</i> have a <code>#</code> in front
      of it.  It also ends with a <code>;</code>.  You may specify
      that it's a <tt>.c</tt> file if you wish, but doing so isn't
      required.
    </p>

    <p>
      Inheritance statements <i>must</i> come before any variable or
      function definitions, including in #include files.  This is one
      reason you can't use the standard include file (mentioned in a
      later chapter) to add a variable to every LPC program -- if you
      did, that variable would be declared before any inheritance, so
      no LPC program could inherit anything!
    </p>

    <p>
      The <b>child</b> object (the one that declares the inheritance,
      as above) will inherit all inheritable functions and variables.
      This means that simply calling a function with the name declared
      in the parent will call that function as the parent defines it.
      Or, if the child defines it, it will be called with the child's
      definition.  That is the power of inheritance -- the same name
      can refer to any of a family of functions, tailored to different
      classes.
    </p>

    <p>
      Variables are also inherited, and can be referred to by name.
      The variable's name, by itself, points to the parent's instance
      of that variable, so it works just like functions.
    </p>

    <p>
      If a child object has a function with the same name as a
      function in the parent, the child's function will <b>mask</b>
      the parent's.  When the function is called by an external call
      to the child, the child function will be executed.  To call the
      parent function from the child, call the function name with the
      scope operator, <code>::</code>, before it.

    <pre>
void my_func()
{
    /* 
     * This function exists in the parent, and I need to
     * call it from here.
     */
    ::my_func();        /* Call my_func() in the parent. */
}
    </pre>
  </p>

    <p>
      If a parent is inherited with a prefix, for example, <tt>inherit
      foo &quot;/usr/bob/fooclass&quot;</tt>, the method above won't
      work.  Instead of calling with a scope operator before it, it
      must be called with the prefix, the scope operator and then the
      function name.  So <tt>::my_func();</tt> above might become
      <tt>foo::myfunc();</tt>.
    </p>

    <p>
      It is not possible to call a masked function in the parent by an
      external call -- only from within the object itself. If an
      object inherits an object that has inherited another object,
      e.g. C inherits B that inherits A, then masked functions in A
      are available in B.  If B masks that function then C will get
      B's version when it calls the function with the scope operator.
      If B doesn't mask the function then C would get A's version
      instead.
    </p>

    <p>
      If a parent is inherited with the <b>private</b> keyword, only
      the class inheriting it will be able to see its functions.
      External function calls won't find the <b>private</b> parent's
      functions, and child classes won't be able to call the functions
      inherited from that parent.  To export the functions in a
      <b>private</b> parent class, have the child class declare
      functions with the same names that pass the arguments through to
      the parent.
    </p>

    <h3><a name="SEC4.2.3" href="index.html#SEC4.2.3">
	Type identification</a></h3>

    <p>
      Due to the fact that all variables are initialized to 0 or nil,
      and that many functions return 0 or nil when failing, it's
      desirable to be able to determine what value you actually have
      received.  If you use the <code>mixed</code> type it's even more
      essential to be able to test what the <b>mixed</b> variable
      contains at any specific time. For this purpose there's a
      special function called <code>typeof()</code>.  It uses
      constants listed in the header file &lt;type.h&gt;.
    </p>

    <p>
      Calling typeof() on a value returns one of the constants from
      <tt>type.h</tt>, though you may get a type different from the
      one the variable has.  For instance, an uninitialized string,
      array or mapping will return T_NIL rather than T_STRING, T_ARRAY
      or T_MAPPING.  This is true even if typeof() is called on a
      variable of type <b>string</b> rather than type <b>mixed</b>.
    </p>

    <p>
      One excellent use for typeof() is to write a function which
      allows multiple possible types for a single parameter and checks
      the type of that parameter inside.  For instance:

    <pre>
#include &lt;type.h&gt;

string mixed_print_to_string(mixed arg)
{
    switch(typeof(arg))
    {
        case T_NIL:
            return "(nil)";
        case T_STRING:
            return "\"" + arg + "\"";
        case T_INT:
        case T_FLOAT:
            return "" + arg;
        case T_OBJECT:
            return "&lt;" + object_name(arg) + "&gt;";
        case T_ARRAY:
            {
                int    ctr;
                string tmp;

                tmp = "({ ";
                for(ctr = 0; ctr < sizeof(arg) - 1; ctr++)
                {
                    tmp += mixed_print_to_string(arg[ctr]);
                    tmp += ", ";
                }
                /* We go one less iteration and then add the final
                   element by hand to avoid a stray comma at the
                   end. */
                tmp += mixed_print_to_string(arg[sizeof(arg) - 1]);
                return tmp;
            }
        default:
            error("We don't print those yet!");
    }
}
    </pre>
  </p>


    <h3><a name="SEC4.2.4" href="index.html#SEC4.2.4">
	Type qualifiers</a></h3>

    <p>
      The types you assign to variables and functions can have
      qualifiers changing the way they work.  It's very important to
      keep these qualifiers in mind and use the proper ones at the
      proper times.  Most work differently when applied to variables
      rather than functions, so try to avoid confusion by remembering
      that, for instance, a static variable and a static function have
      little, if anything, to do with each other.
    </p>


    <h4><a name="SEC4.2.4.1" href="index.html#SEC4.2.4.1">
	The static variable qualifier</a></h4>

    <p>
      <a name="IDX66"></a>

      Static variables must be global variables.  Global variables are
      defined in the file <i>outside</i> any function. These variables
      are available in all functions defined after they are, so their
      <b>scope</b> is object-wide rather than limited to one function.
    </p>

    <p>
      It is possible to save global variables in an object with a
      special function called <code>save_object</code>, described
      later.  If the global variable is declared as
      <code>static</code>, it is <i>not</i> saved along with the
      others.  Note that DGD doesn't particularly recommend using
      <code>save_object</code> anyway -- it's better to use statedumps
      or some other form of structured storage in most cases.
    </p>

    <pre>
static string   TempName;        /* A non-saved global var. */
    </pre>


    <h4><a name="SEC4.2.4.2" href="index.html#SEC4.2.4.2">
	The static function qualifier</a></h4>
    <p>
      <a name="IDX67"></a>

      A function that is declared <code>static</code> can not be
      called using external calls, only internal. This makes the
      function 'invisible' and inaccessable for other objects.  Note
      that child classes of the object may call static functions, so
      it may not be a perfect security solution.  <code>Private</code>
      functions, or functions that check the caller with
      <code>previous_program()</code> may be better for security
      purposes.
    </p>


    <h4><a name="SEC4.2.4.3" href="index.html#SEC4.2.4.3">
	The private function/variable qualifier</a></h4>
    <p>
      <a name="IDX68"></a>

      A variable or function that has been declared as
      <code>private</code> will not be inherited by child objects.
      Private functions and variables can only be accessed by the
      object that defines them.  They are also not saved by
      <code>save_object()</code>.  Note that in MudOS, private
      functions and variables cause an error if they're accessed by a
      child class.  In DGD, they are simply invisible from the child
      objects.
    </p>


    <h4><a name="SEC4.2.4.4" href="index.html#SEC4.2.4.4">
	The nomask function/variable qualifier</a></h4>

    <p>
      <a name="IDX69"></a>

      Functions and variables that are declared as <code>nomask</code>
      can not be masked by inheritance.  Attempting to do so gives an
      error message.
    </p>

    <p>
      Since an internal call will still use the child class's method
      definition by default, <code>nomask</code> functions provide a
      way to be sure what method is being called.  Functions that are
      declared as both <code>static</code> and <code>nomask</code> are
      a powerful way to make sure a function can be called only by
      child classes, but the definition of the function will always be
      known for any child class.
    </p>


    <h4><a name="SEC4.2.4.5" href="index.html#SEC4.2.4.5">
	The atomic function qualifier</a></h4>

    <p>
      <a name="IDX71"></a>

      Atomic functions are very powerful, and are unique to DGD among
      LPC dialects.  Only functions may be declared atomic, not
      variables.  The <code>atomic</code> modifier is used just like
      the <code>static</code> or <code>nomask</code> modifier, before
      a function's name.
    </p>

    <p>
      If a function is declared <code>atomic</code>, it may not read
      or write files in any way, nor may it read or write network data
      on network connections.  Any attempt to do so will cause an
      error.  Atomic functions also use a different Error handler than
      do non-atomic functions.  They use twice the ticks of other
      functions (see <code>rlimits</code> for an explanation of
      ticks).
    </p>

    <p>
      So what's different about them?  The fact that they will either
      fully execute, or nothing will happen.  You can write to global
      variables and data structures in an atomic function, even if
      those variables or data structures are in a different object
      than the atomic function.  If an error occurs and the function
      terminates, those writes to variables and data structures will
      be fully undone.  It is as though the atomic function has never
      been called at all, except for the fact that it causes an error.
    </p>

    <p>
      Atomic functions are one of the most powerful features of DGD.
      They are found in almost no other language.  They are the reason
      for several of the unusual limits DGD has, such as lack of
      callout to code in other computer languages.
    </p>


    <h3><a name="SEC4.2.5" href="index.html#SEC4.2.5">
	switch/case part 2</a></h3>

    <p>
      <a name="IDX73"></a>
      <a name="IDX74"></a>

      The LPC switch statement is very intelligent, it can also use
      ranges in integers:

    <pre>
void wheel_of_fortune()
{
    int i;

    i = random(10);     /* Get a random number from 0 to 9 */

    switch (i)
    {
    case 0..4:
        write(&quot;Try again, sucker!\n&quot;);
        break;

    case 5..6:
        write(&quot;Congrats, third prize!\n&quot;);
        break;

    case 7..8:
        write(&quot;Yes! Second prize!\n&quot;);
        break;

    case 9:
        write(&quot;WOOOOPS! You did it!\n&quot;);
        break;

    default:
        write(&quot;Someone has tinkered with the wheel... Call 911!\n&quot;);
        break;
    }
}
    </pre>
  </p>



    <h3><a name="SEC4.2.6" href="index.html#SEC4.2.6">
	catch/error: Error handling at runtime</a></h3>

    <p>
      <a name="IDX75"></a>

      It happens now and then that you need to make function calls you
      know <i>might</i> result in a runtime error. For example you
      might try to clone an object (described later) or read a
      file. If the files aren't there or your privileges are wrong you
      will get a runtime error and execution will stop. In these
      circumstances it is desirable to intercept the error and either
      alert a user or try alternate solutions to the problem.  The
      special LPC function operator <code>catch()</code> will do this
      for you.  If an error occurs during evaluation of the given
      function, the error is returned.
    </p>

    <pre>
int catch(function)
e.g.
    if (catch(write_file("/usr/bob/logfile", "It works!")))
    {
        DRIVER->message(&quot;You don't have permission to write!\n&quot;);
        return;
    }
    </pre>

    <p>
      <a name="IDX76"></a>

      It's also possible to cause errors.  This is particularly useful
      when you want to notify the user of an unplanned event that
      occured during execution.  For instance, you often want to do
      this in the 'default' case of a switch statement.  In any case,
      <code>error()</code> will generate a runtime error with the
      message you specify.  A <code>catch()</code> statement issued
      prior to calling the function that uses <code>throw()</code>
      will intercept the error as usual.
    </p>

    <pre>
error(string message)
e.g.
    if (test &lt; 5)
        error(&quot;The variable 'test' is less than 5\n&quot;);
    </pre>


    <h3><a name="SEC4.2.7" href="index.html#SEC4.2.7">
	Array and Mapping references</a></h3>

    <p>
      <a name="IDX77"></a>
      <a name="IDX78"></a>

      In computer science terms, arrays and mappings are copied <b>by
      reference</b> and simpler types are copied <b>by value</b> This
      means that arrays and mappings, unlike other variables, aren't
      copied every time they are moved around. Instead, what is moved
      is a reference to the original array or mapping. What does this
      mean then?
    </p>

    <p>
      Here's an example:

    <pre>
object *arr, *copy_arr;

arr = ({ 1, 2, 3, 4 });    /* An array */

copy_arr = arr;	             /* Assume (wrongly) that a copy_arr becomes
                                a copy of arr. */

/* Change the first value (1) into 5. */
copy_arr[0] = 5;
    </pre>
  </p>

    <p>
      It might be logical to assume that the first value of
      <code>copy_arr</code> is 5 while the first value or
      <code>arr</code> is 1.  That's not the case, because what got
      copied into <code>copy_arr</code> was not the array itself, but
      a reference to the same array as <code>arr</code>.  This means
      that assigning an element changed that element in the original
      array to which both variables refer.  <code>copy_arr</code> and
      <code>arr</code> will both seem to have changed, while in fact
      it was only the original array that changed.
    </p>

    <p>
      Exactly the same thing will happen for mappings since
      they are also copied by reference.
    </p>

    <p>
      How do you copy an array or mapping by value?  Usually you want
      to work on a copy and not the original array or mapping.
    </p>

    <pre>
              _ This is just an empty array
             /
copy_arr = ({ }) + arr;
                    \_ This is the one we want to make unique
    </pre>

    <p>
      In this example <code>copy_arr</code> becomes the sum of the
      empty array and the <code>arr</code> array created as an
      entirely new array. This leaves the original unchanged, just as
      we wanted. You can do exactly the same thing with mappings. It
      doesn't matter if you add the empty array or mapping first or
      last, just as long as you do it.
    </p>

    <p>
      You can also copy arrays using array-slice notation.  This is
      probably the most common in existing DGD code.
    <pre>
copy_arr = arr[..];
    </pre>
  </p>

    <p>
      At the end of a thread of execution, any array that is in a new
      object will be copied into that object.  That means you can't
      just store references to a single array in a lot of your objects
      and use those references to share data.  At the end of their
      first thead of execution, each referenced mapping and array will
      be copied into all the objects that reference them, and they'll
      stop being the same as the original.  To share data like that,
      you should put the array in a single object and make a function
      that returns the array.  Then any object that wants to modify it
      can call the function, modify the array and then stop
      referencing it before the thread of execution is over.  You
      could also have separate &quot;get&quot; and &quot;set&quot;
      functions, which would be slower but easier to control.
    </p>

    <p>
      For details on what threads of execution are and when they
      end, see section 5.3.1 in chapter 5.
    </p>

    <hr>
    <a href="http://sourceforge.net">
      <img src="http://sourceforge.net/sflogo.php?group_id=48659&type=6"
	   width="210" height="62" border="0" alt="SourceForge.net Logo"></a>
    <address><a href="mailto:noah_gibbs@yaNOSPAMhoo.com">Noah Gibbs</a>
    </address>
    <!-- Created: Mon Jun 11 21:50:30 PDT 2001 -->
    <!-- hhmts start -->
Last modified: Tue Jul  1 15:01:01 PDT 2003
<!-- hhmts end -->
  </body>
</html>
