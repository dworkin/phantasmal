------  UNQ

UNQ is a Uniform Nested Quotation notation invented by Tom Lokovic.
It's designed to allow for easier embedding of code and more
uniformity than XML.  Nonetheless, it's fundamentally pretty similar
and many of the same tricks work as well or better with it.

The basic notation uses nested curly braces rather than nested angle
brackets so that embedding something that looks like C into it isn't
as much of a bear as it is with XML or HTML (have you noticed that?).
It also allows you to label a phrase with a string by putting the
string after a tilde and before the open curly brace denoting the
start of the data.  For instance:

        ~label{my data goes here}

In UNQ, this would be "my data goes here", labelled with "label".
Pretty simple.  You can also embed UNQ into the data string.  For
instance:

     ~label one{my data ~embedded{including UNQ} goes here.}

The label is optional.  Unlabelled data is assumed to have the empty
string as a label. So these two are the same:

     {bobbity spam} ~{bobbity spam}

However, UNQ will pay attention to whitespace, so these are different
from the preceding example:

     { bobbity spam } {bobbity  spam}  {bobbity
spam}

Note that the last one contains a newline.  That's fine.  A newline is
a character like any other.  It's very slightly harder embedding a
curly brace or a tilde into your string.  You'll need to escape it by
preceding it with a backslash.  For instance:

    ~ my data { contains a \~ tilde }

This UNQ is the string " contains a ~ tilde " with the label " my data ".
That is very different from

    ~ my data { contains a ~ tilde }

which is not parsed as legal UNQ.  Curly braces and backslashes can also
be backslash-escaped to make them come out as literal characters.



------   UNQ DTDs

Like XML, UNQ has Document Type Definitions used to parse UNQ
documents more easily.  They are, naturally enough, also in UNQ.
Unlike XML, they are currently external rather than being embeddable
in the document, though that would be very easy to change in the
future if need be.

For example:

~DTD{
  ~object{name,number?,location?,bdesc,gdesc,ldesc,edesc?,location,nouns,
           adjectives?}
  ~name{string}
  ~location{string}
  ~number{integer}
  ~bdesc{phrase}
  ~gdesc{phrase}
  ~ldesc{phrase}
  ~edesc{phrase}
  ~nouns{phrase+}
  ~adjectives{phrase*}
}

By using an UNQ parser that accepts DTDs, you could turn an UNQ chunk
of the form:

~object{
  ~name{snowglobe}
  ~bdesc{a snowglobe}
  ~gdesc{a snowglobe with a snowman inside}
  ~ldesc{~enUS{The snowglobe has a ~i{snowman} inside, and tiny white flakes
               swirl around inside.}~chicken{chicken chicken chicken}}
  ~edesc{The snowman has a carrot nose!  How cute!}
  ~nouns{{~enUS{snowman}~esUS{hombre de nieve}~chicken{chicken}}
         {snowglobe}
         {globe}{flakes}{snow}}
  ~adjectives{{snowy}{snow-filled}}
}

into a DGD array of the form:

({ "object",
    ({ ({"name", "snowglobe" }),
       ({"bdesc", Phrase("a snowglobe") })
       ({"gdesc", Phrase("a snowglobe with a snowman inside") })
       ({"ldesc", Phrase(/* langs go here*/) })
       ({"edesc", Phrase("The snowman has a carrot nose!  How cute!") })
       ({"nouns", Phrase("snowman"/"hombre de nieve"/"chicken"),
                    Phrase("snowglobe"), Phrase("globe"), Phrase("flakes"),
                    Phrase("snow") })
       ({"adjectives", Phrase("snowy"), Phrase("snow-filled") })
     })
 })

Similarly, multiple objects (or multiple types of DTD entities) could
be concatenated happily into one file.  Currently entity names can't
be scoped -- you can't have "nouns" be available only inside an entity
of type "object" for instance -- but that will likely be altered in
the future.

For UNQ DTDs, acceptable types include string (an ANSI character
string), unq (for any acceptable UNQ parse with no DTD applied),
integer (for a positive or negative whole number), float (for a
floating point number), and may eventually include a length-tagged raw
data type, not yet named.

The + modifier (for instance, for nouns) means "one or more times".
This is why nouns allows multiple phrases in its data above.  The ? 
modifier means "zero or one times", which is why we got away with
leaving out both "location" and "number", each optional, in the object
above.  The adjectives label, in addition to being optional, uses the
* modifier which means "zero or more times."  Thus, you can have no
adjectives section at all (since it's optional) or an empty one (since
it's "zero or more"), or one or two or many adjectives, as the two
above show.  An empty tag may be written as {adjectives~}.
