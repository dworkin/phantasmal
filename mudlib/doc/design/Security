             Phantasmal Security, including Unsecured Areas

- To remain unsecured and essentially public:

   heavy_array
   phrase
   intl_phrase
   simple_phrase
   unq_dtd
   /usr/common/data/lwo_phrase
   /usr/common/lib/lwo/issue
   /usr/common/data/lib_issue
   /usr/common/data/clonable_issue

- To be documented and (if necessary) secured:

   helpd
   soundexd            (keep as public)
   stringd             (keep as public)
   basic_unq_parser    (keep as public)
   unq_parser          (keep as public)
   simple_object
   simple_exit
   room
   container
   exit
   object
   unqable             (keep as public?)
   phrased

- To be secured:

   mapd
   initd
   errord
   logd
   objectd
   phrase_repository
   /usr/System/user  (e.g. set_locale)

Additional Tasks:

Add a secure layer for objects in /usr/common/ of one-off secure
operations hardcoded only to work for them.  For instance, the MAPD
should be able to increment the room count of the wizard creating a
room or veto.  This allows the objects to live in the unprivileged
/usr/common/ subdirectory and make only very specific, very limited
privileged calls.  The name accessd is taken, so perhaps secured,
securityd, or gated.


Security Assumptions:

Number one priority, security-wise, is to make sure that users typing
at a command line can't do anything that can't be done with the
standard, expected commands.

Secondary priority, currently poorly executed, is to give wizards
access only to their own areas.  There are specific interesting
instances (can a wizard remove an exit if he has access only the the
room on one end of it?) that will be resolved either way, but in
general the idea is to separate the MUD up into workable zones and
control permissions to most objects in that way.

Major shared servers should generally secure themselves so that only
privileged (System) code can add or remove elements and commands
should be added to wiztoollib to check permissions, or the server's
configuration should be altered only directly with configuration
files.  Servers like this would include various shared phrase
repositories, the Helpd and the objnumd.

Some daemons (like stringd and soundexd) are secured by simply
providing no privileged services and allocating no data.  This is a
valid approach.  Others, like objectd and telnetd have usage models so
static and controlled that they can check the calling program by name
on almost every call.

The overall secondary goal is to prevent unskilled and (possibly) even
malicious admins with builder access from destroying information they
should have no access to, and to keep them from initiating successful
denial of service attacks.  A combination of careful access control to
shared resources with quotas for their own personal resources will, we
hope, be sufficient in the long term.
